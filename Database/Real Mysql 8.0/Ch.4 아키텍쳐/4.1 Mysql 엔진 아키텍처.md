# Mysql 엔진 아키텍쳐

Mysql서버는 `Mysql 엔진` + `스토리지 엔진` 으로 이루어져 있다.

## 기본 구조

### Mysql 엔진

> sql 문장을 분석, 최적화를 담당한다.

1. sql 서버에서 사람의 머리 역할
2. `커넥션 핸들러`를 통해 외부 어플리케이션과의 커넥션을 맺고 쿼리 요청을 처리하며,
3. 스레드를 관리
4. 쿼리 실행을 위한 처리: sql인터페이스, 전처리기, sql 파서, sql 옵티마이저, 캐시 버퍼 

등으로 구성된다.

<br>

### 스토리지 엔진

> 실제 데이터를 디스크(파일)에 저장하거나 디스크에 저장된 데이터를 읽어오는 역할을 담당한다.

1. 여러개 동시에 사용가능
2. 핸들러 API만 구현하면, 스토리지 엔진을 갈아 끼울수 있다.
3. 크게 `MyISAM`, `InnoDB` 스토리지 엔진이 있다.

디스크의 I/O 작업은 비용이 큰 작업이므로 `MyISAM`은 키 캐시, `InnoDB`는 버퍼 풀을 이용해 메모리에서 빠르게 데이터를 읽어올 수 이따.

<br>

### 핸들러 API
> 클라이언트가 쿼리 실행 시 Mysql 엔진에서 스토리지 엔진에 데이터를 읽어오라고 요청하는데, 이것을 `핸들러 요청`이라고 한다.

즉 Mysql엔진과 스토리지 엔진을 사이에 위치하여 이어주는 역할을 맡는다
핸들러의 구현체가 스토리지 엔진이라 생각하면 된다.


sql 엔진 - 사람
스토리지 엔진 - 자동차
핸들러 - 자동차 핸들

<br>
<br>



---

## 스레딩 구조

sql 서버는 스레드 기반 동작을 하는데, 크게 `Foreground 스레드` / `Background 스레드`로 이루어져 있다.

위에서 언급했듯 스레드의 스케줄링은 sql 엔진이 관리하며,
스토리지 엔진은 백그라운드 스레드가 지시한 페이지 I/O 작업을 수행한다.

<br>

### Foreground 스레드
> sql 서버에 접속한 클라이언트 수만큼 존재하며, 사용자가 요청하는 쿼리 문장을 처리(실행)한다.

클라이언트 스레드라고도 한다.

1. 커넥션 종료 시 스레드 캐시로 돌아간다.  
   :arrow_right: 스레드 캐시에 일정 개수 이상의 쓰레드가 있으면 캐시에 넣지 않고 종료 시킨다(캐시에 존재하면 메모리를 소모하기에 종료시키고 일정 개수만 남김)

2. 캐시와 버퍼에서 데이터를 가져온다.  
    :arrow_right: `innoDb`의 경우 캐시 miss시 디스크 접근은 백그라운드 쓰레드가 관리   
    :arrow_right: `MyISAM`의 경우 캐시 miss시 디스크 접근도 포그라운드 쓰레드가 관리


```
`innoDb`는 클라 요청처리 = 포그라운드 / 디스크 I/O = 백그라운드 로 분업을 하여,
요청 처리시 오래 걸리는 디스크 입출력을 백그라운드에 위임하고 대기했다가(혹은 다른 요청 처리) 버퍼 풀에 올라오면 포그라운드가 가져다 쓰는 방식이다.
이렇게 하여 io 큐의 일관화가 가능하고, 페이지 요청/로드의 비동기 처리가 가능하여 동시성 상황에도 좋은 성능
```

<br>



### Background 스레드

> 버퍼(캐시)와 디스크 사이의 데이터를 관리한다.

1. 버퍼에 데이터 변경내용 디스크에 쓰기
2. 버퍼에 없는 데이터 디스크에서 가져오기
3. 로그를 디스크에 쓰기
4. 락 이나 데드락 모니터링

이때 `읽기 쓰레드 수`  < `쓰기 쓰레드 수`  설정해야 한다
:arrow_right: 읽기 같은 경우 버퍼 풀에서 히트 시 디스크 접근이 필요 없지만 쓰기 같은 경우는 모든 경우에서 디스크에 변경이력을 저장해야 하기 때문

<br>
<br>

---



## 메모리 할당 및 사용구조

### 글로벌 메모리 영역
> 많은 쓰레드가 공유하는 메모리여서 글로벌 영역에 관리되고, 서버 시작 시 OS 가 할당한다.

1. innoDB 버퍼 풀 - 데이터를 페이지 단위로 캐싱해둔 공간
2. MyISAM 키 캐시 
3. 테이블 캐시 - 테이블의 메타 데이터 
5. 리두 로그 버퍼 - 트랜젝션 변경내용 임시 저장소 
6. 어댑티브 해시 인덱스 - 자주 사용되는 데이터에 대해 자동으로 해시 인덱스를 생성해 O(1) 로 읽기 가능하게 함 (디스크엔 저장 x)
7. 바이너리 로그 버퍼

<br>

### 세션 메모리 영역
> 클라이언트 스레드가 쿼리를 처리할때 사용하는 영역

1. 조인 버퍼
2. 정렬 버퍼
3. 네트워크 버퍼
4. 리드 버퍼

각 클라 스레드 별로(세션별로) 독립적으로(선택적으로) 할당되는 버퍼  
  :arrow_right: 조인 버퍼, 정렬버퍼
(조인과 정렬같은 기능은 쿼리마다 실행 될 수도 아닐수도 있으니)


각 클라 스레드 별로(세션별로) 항상 할당되는 버퍼  
  :arrow_right: 커넥션, 결과, 네트워크 버퍼

<br>
<br>

---
## 쿼리 실행 구조

![출처: https://rrhh234cm.tistory.com/140](https://github.com/user-attachments/assets/ec277f23-0462-4352-acce-2e9cf968224a)

### 쿼리 파서
> 요청 쿼리문을 토큰으로 분리하여 트리 형태의 구조로 변환한다

Q. 토크나이징하고 트리로 만드는 이유?  
  :arrow_right: 트리로 구조화 해두면, 추후 옵티마이저가 해둔 쿼리를 쉡게 이해하고 실행계획을 최적화할 수 있다.

이때 기본 문법 오류는 쿼리 파서에서 걸러진다.

<br>

### 전처리기 
> 만들어진 쿼리 트리를 기반으로 구조적인 문제점을 파악한다.

1. 쿼리와 테이블의 메타 데이터를 매핑한다. (테이블 이름과 컬럼이 존재하는지? 내장함수 등 알맞게 쓴 쿼리인지?)
2. 접근 권한을 확인 

이러한 구조적인 문제를 거른다.

<br>

### 옵티마이저
> 쿼리 문장의 실행 계획을 최적화 한다.

다른 챕터에서 자세히 다룰 예정이다.


<br>

### 실행 엔진(실행기)
> 쿼리 실행 계획에 따라 핸들러에게 쿼리를 위한 요청을 보내고 처리한 내용을 또 다른 핸들러의 요청으로 연결해 준다.

cf) 쿼리 수행 예시
```
1. 실행 엔진이 핸들러에 쿼리 결과를 담을 임시 테이블 생성 요청
2. 다시 where 절에 일치하는 레코드 읽어오라 핸들러에 요청
3. 결과를 임시 테이블에 저장하라고 요청
4. 이런식으로 쿼리가 완료 되면 임시 테이블의 데이터를 읽어오라고 요청
5. 최종 데이터 사용자에 응답
```

핸들러는 실행 엔진의 요청에 따라 데이터를 읽고 쓴다.


<br>
<br>



## 쿼리 캐시
> SQL 실행 결과를 메모리에 저장해 두고, 동일한 SQL이 들어올 경우 디스크나 버퍼 풀에 다시 접근하지 않고 바로 결과를 반환하는 기능이다.

하지만 동시처리 성능 저하 때문에 MySQL 8.0에서 완전히 제거되었다.

### Q. 왜 없어졌을까?
1️⃣ 전역 락(Global Lock) 문제  
쿼리 캐시는 글로벌 메모리 영역에 존재하며, 여러 스레드가 동시에 같은 캐시에 접근하거나 수정하려고 하면  
→ 일관성 보장을 위해 락을 걸어야 한다.  
예를 들어 한 스레드가 캐시된 결과를 조회하는 순간, 다른 스레드가 테이블을 업데이트하면 결과가 불일치할 수 있으므로 락을 강하게 유지해야 했다.  
→ 결국 락 경합으로 인해 동시성 성능이 떨어졌다.

2️⃣ 캐시 무효화 비용   
쿼리 캐시는 테이블 단위로 결과를 기억하기 때문에 해당 테이블에 데이터 변경(INSERT, UPDATE, DELETE)이 일어나면  
→ 해당 캐시에 저장된 모든 결과를 무효화(Invalidation) 해야 한다.  
이 무효화 과정 역시 락을 걸어야 하고, 테이블 변경이 자주 일어나면, 캐시 무효화/재생성 비용이 더 커진다


이때 버퍼 풀과는 전혀 다른 것임에 주의하자.
```
버퍼 풀: 디스크에 있는 데이터를 페이지 단위로(16KB) 메모리에 캐싱
쿼리 캐시: 쿼리 실행 결과를 통쨰로 캐싱 ->  but 동시처리 성능 저하로 8.0에선 폐기
```

<br>
<br>

---
## 스레드 풀
> 클라이언트 스레드의 개수를 줄여 동시 요청이 많아도 mysql 서버의 cpu가 제한된 개수의 스레드만 처리할 수 있게 하여 자원 소모를 최소화 한다.

### Q. 왜 클라이언트 스레드의 상한을 걸면 자원 소모를 줄일 수 있을까?  
1️⃣ context 스위칭 비용감소  
스레드 수가 많아질수록 OS 스케줄러는 많은 작업을 밀고 당기며 CPU를 분배해야한다
→ 이때 발생하는 컨텍스트 스위칭(context switching) 비용이 커져서 CPU의 사용률이 커지게 됨다.


2️⃣ 메모리 사용량 감소   
스레드마다 스택, TLS(Thread Local Storage), 커널 구조체 등 고정 메모리 자원이 할당되므로
너무 많은 쓰레드의 개수는 오히려 성능저하로 이어진다.

3️⃣ 락 경합 감소   
스레드 많을수록 동시 요청이 많아지기 때문에 락경합이 많아진다.

즉 CPU가 감당 가능한 수준의 스레드 개수로 운영을 해야 최대 효율을 뽑을 수 있따.
때문에 CPU 코어 개수만큼 `스레드 그룹`을 생성해야 한다
(스레드 그룹안엔 워커 스레드가 여러개 존재)


스레드 그룸에 모든 워커 스레드가 일을 처리하고 있다면,
`thread_pool_stall_limit`변수에 설정된 시간 만큼 기다린뒤 스레드 풀은 해당 그룹에 새로운 워커 스레드를 추가한다.

<br>
<br>

---
## 트랜잭션 지원 메타 데이터

이전 버전에는 메타 데이터의 변경 작업이 트랜잭션 지원을 안해 테이블 생성 변경시 서버가 비정상 종료되면 
일관성이 깨질수 있었다.
때문에 8.0 에선 메타 데이터 + 시스템 테이블(서버 동작 위한 정보와 권한정보를 담은 테이블)를 `InnoDB 테이블`에 저장하여 트랜잭션을 지원한다.
