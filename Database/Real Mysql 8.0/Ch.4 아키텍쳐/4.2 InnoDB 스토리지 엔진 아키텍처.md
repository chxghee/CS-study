# 4.2 InnoDB 스토리지 엔진 아키텍처

## InnoDB 스토리지 엔진

현재 Mysql 스토리지 엔진 중 가장 많이 사용되며
이렇게 가장 많이 사용되는 이유에는 `레코드 기반 잠금을 유일하게 지원`하기 때문이다.

이러한 락 지원 덕분에 높은 동시성 처리를 지원할 수 있다.


InnoDB 스토리지 엔진의 구조는 다음과 같다.
![image](https://github.com/user-attachments/assets/1d18fe39-4dc6-49a1-afb9-9a31a92624ae)



<br>

---

## PK 클러스터링
> InnoDB의 모든 테이블은 PK값을 기준으로 클러스터링 되어 저장된다.

이말은 즉슨, PK 값의 순서대로 디스크에 저장된다는 것이다.
추가적으로, 세컨더리 인덱스는 레코드의 주소 대신 PK값을 논리 주소로 사용하여 디스크 내 데이터의 위치를 찾을 수 있다.

이렇듯 PK 가 클러스터링 인덱스이기 떄문에 PK를 이용한 조회의 레인지 스캔은 상당히 빨리 처리될 수 있다.(클러스터링 되어 저장되기 때문에 순차 탐색을 하면된다)

이와 달리 MyISAM의 PK 인덱스와 세컨더리 인덱스는 구조적으로 동일하다.(유니크 제약이 붙은 세컨더리 인덱스인 것이다)
그리하여 레코드의 물리 주소를 항상 가르킨다.

<br>

---

## 외래키
> InnoDB에서는 부모(참조된) 테이블과 자식(참조하는) 테이블 에서 해당 키에 대한 인덱스 생성이 필수적이다

왜냐하면, 데이터 변경시 부모,자식의 각 테이블을 스캔하여 데이터를 확인해야 하므로 이 과정을 인덱스를 생성하여 빠르게 진행할수 있게 하기 위함이다.

하지만 이렇게 데이블 스캔으로 확인하는 작업은 락의 전파를 야기하고 데드락이 발생 가능하다.
이를 해결하기 위해 항상 부모 -> 자식 순서로 트랜젝션을 정렬해야 한다.

<br>

<br>

---

## MVCC (Multi Version Concurrency Control)
> MVCC는 읽기 요청 시 잠금을 사용하지 않고, undo log를 이용해 일관된 읽기(Consistent Read) 를 제공하는 방식이다.

여기서 "멀티 버전"이란, 하나의 레코드에 대해 여러 버전을 동시에 관리한다는 의미다. 
데이터 변경 시 undo log를 생성하여 이전 버전을 남기고, 트랜잭션은 이 로그를 참조해 자신에게 일관된 스냅샷을 제공받는다.

→ 덕분에 읽기 작업은 잠금 없이 수행 가능하며, 쓰기 작업과 충돌 없이 병행 처리 성능을 높일 수 있다.


우선 이 트랜잭션의 격리 수준에 대해 알아보자

### 트랜잭션 격리 수준
1. `READ_UNCOMMIT`: 다른 트랜잭션의 미커밋 데이터도 읽을 수 있음.   
   :arrow_right:  Dirty Read 가능
2. `READ_COMMIT`: 커밋된 데이터만 읽음.   
   :arrow_right:  같은 트랜잭션 내에서도 읽을 때마다 값이 바뀔 수 있음.
3. `REPEATABLE_READ`: 트랜잭션 시작 시점의 스냅샷을 기준으로 읽음.      
   :arrow_right:  같은 데이터를 여러 번 읽어도 항상 같은 값
4. `SERIALIZABLE`: 가장 엄격한 격리 수준. 트랜잭션 간 순차적으로 실행된 것처럼 보장함.   
   :arrow_right:  내부적으로 범위 잠금 등 추가 제약을 둠.

MySQL의 InnoDB 스토리지 엔진은 기본적으로 MVCC를 사용하여, READ COMMITTED, REPEATABLE READ 수준에서 읽기 잠금(S-lock) 없이도 논리적 격리 수준을 보장한다.

단, SERIALIZABLE은 **읽기에도 잠금(S-lock)**을 걸어야 하므로 MVCC의 이점이 줄어든다.


<br>
<br>

### 격리 수준 READ_COMMIT인 서버의 예시

1. insert 후 commit 완료  
   :arrow_right:  커밋되고 백그라운드 쓰레드가 디스크에 write 완료한 상황    
   (`id:1 | name: sam`)

2. update 후 commit X (이름을 mike 로 변경)  
   :arrow_right:  이전 내용인 `id:1 name: sam`을(바뀐 컬럼과 PK만) undo log 에 복사한다(우선 메모리에 저장)  
   :arrow_right:  버퍼 풀에는 바뀐 내용이 저장되고, 기존 데이터는 언두 로그에 복사된다.  
   :arrow_right:  이때 커밋이 되지 않았더라도 백그라운드 쓰레드는 버퍼 풀의 내용을 디스크로 저장가능하다.(만약 롤백이 되면 언두로그에서 이전 데이터를 찾아 복구한다.)
   (버퍼 풀 or 디스크: `id:1 | name: sam` / 언두 로그: `id:1 | name: sam`)

#### Q. 이 상황에서 다른 Tx가 조회를 한다면?
격리 수준에 따라 결과가 달라질 수 있다.
```
READ_COMMIT: 언두 로그의 데이터를 반환
READ_UNCOMMIT: 현재 버퍼 풀의 내용을 반환
```


3. 롤백 시  
   :arrow_right:  언두로그에서 이전 데이터를 찾아 버퍼 풀에 복구한다.  
   
5. 커밋 시
   :arrow_right: 커밋 되어도 언두 로그의 내용을 바로 삭제하지 않는다. (모든 트랜잭션이 언두 영역의 러코드를 참조하지 않는다면 로그를 삭제한다.)

<br>
<br>


#### 장점
> 정리하자면,  InnoDB는 격리수준이 `SERIALIZABLE`이 아니라면 `MVCC` 를 통해 잠금없이 일관된 읽기를 제공한다.
즉 여러 쓰레드가 동시 읽기 요청을 해도 락을 걸지 않기 때문에 **락 대기 없이 바로 조회 쿼리를 실행할 수 있다.**

#### 단점
> 하지만 트랜잭션이 오래 지속되면 언두 로그 메모리에 데이터가 쌓이고, 이와 얽힌 다른 언두 로그도 **삭제를 할 수 없기 떄문에 메모리의 낭비가 커진다.**

그렇기 떄문에 시작한 트랜잭션은 가능한 빨리 커밋되어 종료할 수 있도록 해야 한다.


<br>
<br>

---
## 자동 데드락 감지
> InnoDB는 데드락 감지 기능도 제공하는데, 이를 위해 `잠금 대기 목록을 그래프`로 관리한다.  
> 이때 데드락 감지 쓰레드(백그라운드)를 통해 주기적으로 그래프를 검사하여 데드락을 모니터링 하고, 발생시 트랜잭션 하나를 강제 종료시켜 데드락을 해결한다.

- 이떄 종료시키는 트랜잭션의 기준은 언두 로그 레코드를 가장 작게 가진 것을 종료한다.  
(롤백 시 언두 해야 하는 내용이 적어 부하가 적기 떄문)

- 동시 처리 쓰레드의 개수가 많거나 각 트랜잭션이 가진 잠듬의 개수가 많아지면 데드락 감지 쓰레드가 느려진다.
  (데드락 감지 위해 `잠금 대기 목록을 그래프`를 순회시 그래프에도 잠금을 걸어야 하기 때문이다)

- 또한 락 검사중에는 다른 TX의 락을 처리할수 없어 서비스 처리 쓰레드도 대기해야한다.

이러한 문제를 개선하기 위해
락 감지 쓰레드 설정을 끄고, lock_wait_time을 50 초 미만으로 설정하여 데드락으로 인해 잠금을 획득하지 못하고 타임 아웃 시켜 
해당 서비스 쓰레드의 쿼리를 실패하게 할 수 있다.


```
InnoDB 스토리지 엔진이 관리할 수 있는 락은 레코드 범위인데,
Mysql가 관리하는 테이블 단위의 락을 스토리지 엔진이 관리할 수있게 하려면 innodb_table_locks 변수를 활성화 해야 한다.
```


<br>
<br>

---

## 자동화된 장애 복구
> InnoDb는 "서버 시작 시" 완료되지 않는 트랜잭션이나 디스크에 일부만 기록된 데이터에 대한 복구 작업을 자동으로 실행한다.

즉 종료 시 불완전한 작업을 재부팅시 마저 작업하는 것이다.

1. REDO: 커밋 했지만, 디스크에 반영되지 않는 데이터 페이지 디스크 write (디스크x 버퍼풀에만 저장된 상태에서 종료되었을떄)
2. UNDO: 커밋 x 상태의 트랜잭션 변경사항 롤백
3. Double Write 버퍼 검사: 버퍼 풀의 데이터 페이지가 "일부만" 디스크에 반영되었다면(페이지 데이터를 디스크에 쓰는 도중 비정상 종료시) Double Write 버퍼(디스크에 위치)에서 검사 후 복구한다.


InnoDb엔진은 자동 복구 작업시 언두 레코드를 이용해 데이터 페이지를 복구하고 그 다음으로 리두 로그를 적용해 장애 시점의 상태를 재현한다.

어려 이슈로 자동복구에 실패하면 서버가 시작되지 않음   
 :arrow_right: innodb_force_recover 변수를 1~6까지 단계적으로 설정해 보며 복구를 해야 한다.

### innodb_force_recover 변수 설정
> 원인을 모르갰으면 1부터 6까지 변수를 올려가면서 복구를 해보자  
> 값이 클수록 심각한 상황


```
단계	설명
1	테이블의 데이터 파일, 인덱스 페이지  손상 시 무시 실행하고 데이터를 덤프한 뒤 다시 DB를 구축
2	쓰레드 언두 데이터 삭제과정에서 에러 발생 시
3	커밋되지 않은 트랜잭션 롤백하지 않고 강제 시작(이떄도 데이터 덤프하고 다시 DB구축하는게 좋다)
4	인서트 버퍼 내용무시하고 강제로 시작(이떄도 데이터 덤프하고 다시 DB구축하는게 좋다)
5	언두로그를 무시하고(커밋되지 않은 내용 롤백하지 않고)서버 시작 (이떄도 데이터 덤프하고 다시 DB구축하는게 좋다)
6	리두로그를 무시하고(디스크x 버퍼풀에만 저장된 상태를 놔두고)서버 시작 (이떄도 데이터 덤프하고 다시 DB구축하는게 좋다)
```

어느정도 데이터 손실을 감수하고 서버라도 시작하게 하여 덤프 파일이라도 받아 다시 데이터베이스를 구축하는것이라고 생각하면 됫듯 하다.
즉 따로 바이너리 로그가 존재한다면 이 데이터를 써서 복구하는 것이 더 좋을 수 있다.

<br>
<br>

---

## InnoDB 버퍼 풀
> 메모리 영역에 위치하며, 디스크의 데이터와 인덱스 정보를 메모리에 캐싱하고,
> 사용자 요청으로 인한 데이터의 변경내용은 쓰기 지연으로 일괄적으로 디스크에 write 하여 디스크 접근 횟수를 낮춘다.

디스크 i/o는 비용이 크므로 쓰레드가 데이터를 변경할떄마다 디스크에 접근하게 되면,  
매번 락과 i/o대기가 생겨 성능이 떨어질 수 있따.

버퍼 풀은 메모리에서 관리되기 떄문에 서버가 내려가면 같이 데이터가 휘발된다.
이러한 점은 서버 재시작시 초반 성능이 매우 떨어질 수 있는데,   
버퍼 풀을 덤프하여 시작시 백업을 할수도 있따.

<br>

### 버퍼 풀의 크기 설정
> 클라이언트 쓰레드가 사용할 메모리를 고려하여 설정을 해야 한다.

각 클라이언트 쓰레드는 레코드 버퍼라는 메모리 공간을 할당받게 되는데,
커넥션이 많고 각 세션이 사용하는 테이블이 많다면 레코드 버퍼 메모리도 가 많이 필요하다.
이러한 레코드 버퍼의 크기는 동적으로 변화하기 떄문에 직접 고정값으로 설정할 수 없다.    

:arrow_right: 떄문에 버퍼 풀의 크기를 조정하여 메모리 공간 할당 최적화를 해야 한다.   
 (전체 메모리 공간의 50% 부터 조금씩 128MB 단위로 늘려가며 조정해야 한다.)

```
서버 운영시 풀의 크기를 줄이는 것은 아주 위험하다.
갑자기 줄어든다면
캐시 히트율이 감소 ->  디스크 I/O 증가 -> 해당 쓰레드 블로킹 -> 컨텍스트 스위칭 발생 -> CPU 사용률 증가 -> ...
등등으로 이어져 초반에 성능이 매우 떨어질수 있다.
그래서 조금씩 늘려가며 찾는것이다.
```


<br>


### 버퍼 풀 인스턴스
하나의 버퍼 풀에서 여러 쓰레드가 읽고 쓰려고 한다면 버퍼 풀에도 락을 걸어야 했다.    
:arrow_right: 이렇게 되면 블락되는 쓰레드가 많아져 성능이 떨어지게 됨    
:arrow_right: 버퍼 풀을 `버퍼 풀 인스턴스`라는 단위로 쪼개서 독립적으로 운영   


<br>

### 버퍼 풀의 구조
> 버퍼 풀은 메모리를 페이지(16KB)로 나누어 데이터를 저장한다.

이러한 페이지 조각을 관리 하기 위해 각 `버퍼 풀 인스턴스`별로 다음의 자료구조를 활용하여 관리한다.
1. LRU 리스트 - LRU 리스트는 버퍼 풀에 적재된 페이지들을 최근 사용 시점 순서로 관리
2. Flush 리스트 - 더티 page 목록을 관리
3. Free 리스트 - 비어 있는 메모리 페이지의 목록


<br> 

### LRU 리스트
> LRU 리스트는 버퍼 풀에 적재된 페이지들을 최근 사용 시점 순서로 관리하여,  
> 오래 사용하지 않은 페이지부터 교체(eviction)할 수 있도록 하는 목록이다.

내부적으로 `LRU`(Least Recently Used) + `MRU`(Most REcently Used) 를 이어 붙여 사용한다.

![image](https://github.com/user-attachments/assets/72b99b3a-70ee-4786-b334-ef7d9bd4f5d0)

이를 통해 한번 디스크에서 읽은 데이터는 최대한 버퍼 풀에 오래 머물도록 할 수 있따.

### 데이터 찾는 과정 정리

#### 1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사  
  1-1. 어댑티브 해시 인덱스를 이용해 페이지 검색  
  1-2. 없다면 인덱스(B-Tree)를 이용해 페이지 검색  
  1-3. 버퍼 풀에서 찾았다면 LRU 리스트 위쪽으로 이동  


#### 2. 버퍼 풀에 없다면 디스크에서 페이지를 찾아 적재 후 포인터를 LRU 헤더에 추가

#### 3. 오래 사용되지 않은 페이지들은 끝으로 밀려나고 버퍼 풀에서 제거된다.
이떄 Free 리스트에 빈 페이지를 추가하게 됨



### 어댑티브 해시 인덱스 AHI
> 특정 인덱스가 자주 사용되면 자동으로 해시 테이블을 생성해 `인덱스 키 - Page 주소`쌍으로 저장하여 인덱스 트리 탐색 없이 O(1)로
> 페이지를 찾을 수 있도록 한다.


<br>

### Flush 리스트
> 아직 디스크에 변경내용이 쓰여지지 않은 더티 페이지의 목록을 관리한다.

데이터 변경시 
1. 리두 로그에 저장
2. 버퍼 풀 페이지에 저장된다.

하지만 리두 로그가 디스크에 저장되어 있다 해도 더티 페이지는 디스크에 저장되어 있음을 보장할 수 없다

이떄 체크 포인트를 발생시켜 디스크의 리듀 로그와 데이터 페이지의 상태를 동기화 한다.
이 체크 포인트(동기화 시점)는 리두 파일에 기록된다

<br>

버퍼 풀을 성능저하 없이 플러시 하기 위해 
1. 플러시 리스트 플러시
2. LRU 리스트 플러시를 사용한다.


### 플러시 리스트 플러시
> 플러시 리스트의 오래된 더티 페이지는 주기적으로 동기화 된다.

- 이떄 플러시 되는 더티 페이지의 크기가 크다면 I/O 병목이 발생해 쿼리 성능이 떨어질 수 잇다
- 플러시를 해주는 쓰레드는 `클리너 쓰레드`라고 하는데, 이 클리너 쓰레드를 버퍼 풀 인스턴스와 1-1 로 배정하여 더티 페이지의 크기가  너무 크지 않도록 조정한다.

추가적인 기능으로, 
- `Adaptive Flush` 기능: 리두 로그의 증가속도를 분석하여 적절한 수준의 더티 페이지가 풀에 유지될수 있도록 유지한다.
- 이떄 활성 리두 공간 크기가 10% 이상이라면 이 기능이 동작한다.

<br>

### LRU 리스트 플러시
> 새롭게 풀에 적재될 자리 마련을 위해 LRU 리스트의 끝부분을 스캔하여 더티 페이지는 동기화 / 클린 페이지는 프리 리스트로 보내 재할당 가능한 상태를 만든다.





<br>
<br>

---

### 버퍼 풀과 리두 로그

버퍼 풀은 성능 향상 전략은 다음과 같다.
1. 데이터 캐싱 - 
2. 쓰기 버퍼링 - 

- 이떄 버퍼 풀의 메모리를 늘리면 단순 캐싱 성능만 향상되고, **버퍼링 성능 향상위해선 리두 로그 관계를 고려해야 한다.**

리두 로그 파일은 여러개의 고정 크기 로그파일을 연결해 원형 순환 구조로 디스크에 저장된다.    
:arrow_right: 리두 로그 파일의 크기는 고정되어 있으므로 파일이 다 차면, 다시 첨으로 돌아가 덮어 쓸 수 있다.  
:arrow_right: 덮어쓰기 위해서는 체크 포인트가 기록되어 있어야한다.  

덕분에 리두 로그 파일이 무한정으로 커지는 것을 막을 수 잇다.

- 로그의 포지션은 계속 증가하는 시퀀스 번호(LSN)을 갖는다.
- 체크포인트 이벤트시 리두 버퍼, 더티 페이지를 플러시 하고 세이브 포인트를 LSN으로 저장한다.
- `가장 마지막 체크 포인트 LSN` - `마지막 리두 로그 엔트리 LSN` = 체크 포인트 Age 이다.

```
`가장 마지막 체크 포인트 LSN` - `마지막 리두 로그 엔트리 LSN` = 체크 포인트 Age
```
즉 활성 리두 공간의 크기인데 **아직 디스크에 플러시되지 않은 변경 데이터의 양을 의미한다.**
-> 더티 페이지는 리두 로그 파일의 최대 체크 포인트 Age 를 넘을 수 없다.


<br>

#### Q. 버퍼 풀 100GB / 리두 로그 파일 100MB 일떄?
```
리두 로그가 100메가라 최대 체크 포인트 Age도 100MB이다.
즉 버퍼 풀에  기록할 수 있는 더티 페이지의 크기또한 100MB로 제한된다.
-> 버퍼 풀이 커도 의미가 없어짐
```

> 정리하자면 리두 로그 파일의 크기는 더티 페이지의 크기의 최대 상한을 정하는 기준이 되며, 쓰기 버퍼링 성능을 좌우 할 수 있다.

추가로, 
더티 페이지의 크기가 작으면 -> 더티 페이지를 오래 유지하기가 어렵고 -> 자주 플러시 해야 해서 -> 성능이 저하됨

<br>
<br>

---


## Double Write Buffer


- Partial-page: 더티 페이지를 플러시 시 페이지의 일부만 반영이 된것
- 리두 로그는 변경 사항만 저장하기에 위와같은 페이지의 손상은 복구가 불가능하다.

이러한 문제를 해결하기 위해  `Double Write Buffer` 를 사용한다.
> 메모리가 아닌 시스템 테이블 스페이스(디스크 영역)에 위치하여 실제 데이터 파일에 변경 내용을 기록하기 전에 동기화 되는 더티 페이지를 묶어 기록하는 것

실제 데이터 파일에 쓰기가 성공하면 `Double Write Buffer`에 저장된 내용은 다음 쓰기때 덮어씌어 진다.

<br>

```
cf) 플러시 과정의 작동 순서
1. 더티 페이지 플러시 하려함
2. 첫번쨰 쓰기: 더티 페이지 모아를 디스크의 Double Write 영역에 한번에 기록
3. 두번쨰 쓰기: 실제 데이터 파일에 변경내용 쓰기 
```

<br>

#### Q. Double Write 방식이 HDD보다  SSD 디스크에서 부담인 이유
```
하드디스크(HDD)는 자기 디스크가 회전하는 순차 I/O 환경이라, 동일 위치에 덮어쓰기가 상대적으로 용이하지만 
SSD는 플래시 메모리 특성상 덮어쓰기(overwrite) 가 불가능하여, 데이터를 쓰기 전에 반드시 해당 블록을 지우고(erase) 다시 써야 하기 떄문
```

<br>
<br>

---
## Undo Log
> 커밋 x 시 변경 이전 데이터로 복구하기 위한 로그

언두 로그는 다음의 기능을 지원한다.

1. 트랜잭션을 보장 (롤백)
2. 격리 수준 보장 (격리 수준에 따라 읽기 요청의 동시처리 가능)

### 언두 로그 레코드 모니터링
늘어난 언두 로그 파일 공간은 성능상 다시 줄지 않는다.
(디스크 공간의 해제는 성능저하를 유발 가능 -> 재할당 방식으로 언두로그 관리)


[언두 로그의 양이 매우 증가할 수 있는 상황]
1. TX 지속시간이 길때 (사용자가 트랜잭션 열고 방치)
2. 대용량 데이터의 삽입, 변경 시

하지만 언두 로그는 트랜잭션이 완료 되었다 해도 바로 삭제가 불가하다.
(체인 방식으로 같은 레코드를 읽고 쓰는 트랜잭션이 연결되어 있기 떄문에 이 모든 트랜젝션이 끝나야 삭제가 가능하다.)

이러한 상황이 발생하면 디스크 내에 언두 로그가 쌓여 공간이 계속 증가할 수 있다.

> 즉 이러한 상황을 예방하기 위해 언두 로그 레코드의 증가를 모니터링 해야 한다.

<br>
<br>

### 언두 테이블 스페이스 관리

이전 Mysql 버전에서는 언두 로그를 하나의 물리 파일인 `시스템 테이블 스페이스`에 저장하여 관리했다. 
이 공간에는 인덱스, 테이블 정보 등 메타 데이터가 같이 저장된다.

이 파일은 하나의 물리 파일이기 떄문에 필요상 쓰레드 별로 접근이 많이 필요한 언두 로그는 파일을 나눌 수 없어 병렬접근이 불가능한 상황이었다.   

:arrow_right:  8.0 부터는 언두 로그를 `Undo 테이블 스페이스`로 따로 관리하고, **디스크에 저장된 파일을 세그먼트로 분리할 수 있게 되었다.** 

[Undo 테이블 스페이스 구조]
1. 여러개의 Undo 테이블 스페이스를 가질 수있다.
2. Undo 테이블 스페이스는 1개 이상 128개 이하의 `롤백 세그먼트`를 갖는다.
3. 롤백 세그먼트는 1개 이상의 `언두 슬롯`을 가진다. (언두 로그를 1개씩 쓰는 공간)

트랜잭션이 시작되면, 롤백 세그먼트를 선택하고 슬롯을 할당한다.


[트랜잭션과 언두 슬롯의 관계]
트랜잭션별로 DML에 따라 최대 4개의 언두 슬롯을 가질 수 있다.
즉 최대 동시 트랜잭션 수는 아래와 같다.
```
최대 동시 트랜잭션 수는 = 언두 슬롯 개수 = 언두 테이블 스페이스 개수 * 롤백 세그먼트 개수 * 롤백 세그먼트 별 슬롯의 개수
```

즉 동시 요청이 많은 상황에서 남은 언두 슬롯이 없다면 트랜잭션을 시작 할 수 없는 상황이 발생한다.

> 떄문에 동시 실행 가능한 트랜잭션 개수에 맞게 언두 테이블 스페이스와 롤백 세그먼트의 개수를 설정해야 한다.


<br>

[언두 테이블 스페이스 공간의 반납]
>  언두 테이블 스페이스 truncate 라고 한다.

언두 테이블 스페이스 공간의 반납은 실제 디스크의 언두 파일 영역을 반납하는 것이 아니라,

실제로 언두 로그에 기록된 불필요한(커밋 완료되고, 참조되지 않는) 언두 레코드를 삭제하고
해당 언두 레코드를 담고 있던 언두 페이지(16KB 단위) 를 비어 있는 상태로 되돌려
다시 언두 영역 안에서 재사용 가능하게 만드는 것이다.


1.  자동 모드 (`innodb_undo_log_trancate=ON`)   
  - 커밋된 로그 대상으로 페이지 `Purge 쓰레드`가 주기적으로 꺠어나서 불필요한 로그를 삭제하고 공간을 반납할 수 있다.

3.  수동 모드 (`innodb_undo_log_trancate=OFF`)  
  - 언두 테이블 스페이스를 잠시 비활성화 하면, 퍼지 쓰레드가 불필요한 공간을 반납한다.
  - 이떄 비활성화 해둔 스페이스를 다시 활성화 해 주어야 한다.
  - (최소 3개 이상의 언두 테이블 스페이스가 있어야 가능하다. - 1개씩 비활성화 하고 풀고를 함)



<br>
<br>

---
## 체인지 버퍼
> 체인지 버퍼는 `보조 인덱스`의 변경 내용을 임시로 저장해 디스크 I/O를 줄이는 InnoDB의 버퍼링 기술이다.

[레코드 삽입·수정 시 보조 인덱스와 체인지 버퍼의 동작]

1️⃣ 레코드의 INSERT / UPDATE / DELETE가 발생하면  
→ 해당 레코드가 포함된 PK(클러스터형 인덱스) 페이지는 반드시 갱신되어야 함  
→ 이 PK 인덱스는 레코드를 그대로 저장하므로 즉시 변경  

2️⃣ 하지만 보조 인덱스(Secondary Index) 도 함께 업데이트가 필요하다.  
보조 인덱스는  
	•	PK가 아닌 컬럼을 기반으로 한 인덱스  
	•	즉, 테이블의 다른 컬럼(예: name, email 등)에 대해 빠른 검색을 가능하게 함  
	•	실제 레코드의 PK 값을 참조하는 참조형 인덱스이기 떄문에 PK인덱스는 항상 변경 즉시 반영해야 한다.   

3️⃣ 보조 인덱스 페이지가 버퍼 풀에 이미 올라와 있으면    
→ 즉시 수정 가능  

4️⃣ 버퍼 풀에 없는 보조 인덱스 페이지라면    
→ 디스크에서 인덱스 페이지를 읽어 수정해야 하는데,  
→ 이때 디스크 I/O가 무거운 비용을 초래  

5️⃣ 그래서 InnoDB는 체인지 버퍼(Change Buffer)를 사용  
	•	보조 인덱스 변경 내용을 체인지 버퍼에 먼저 기록  
	•	이후 버퍼 머지(merge) 쓰레드가 비동기적으로 체인지 버퍼의 내용을 보조 인덱스 페이지에 병합(머지)  

 이렇게 하여 디스크 접근 횟수를 줄일 수 잇따.

 

<br>
<br>

---
## 리두 로그 및 로그 버퍼 

[서버 비정상 종료 시]
1. 커밋 x 파일에 저장 o - 언두를 복사
2. 커밋 but 파일 저장 x - 부팅 후 리두 로그 복사

> 이떄 트랜잭션의 변경이 커밋이 되었는지 안 되었는지, 실행중 이었는지 등을 확인할 수 있는 것은 리두 로그의 `커밋 레코드`를 통해 이루어 진다.

리두 로그는 트랜잭션 커밋 즉시 디스크에 쓰여 져야 데이터의 영속성을 만족할 수 있다.
(보통은 이렇게 동작 하지만 설정에 따라 1초에 한번씩 동기화가 될 수도 있다.)

- 앞서 살펴 보았지만 리두 로그파일의 크기는 더티 페이지의 크기를 결정하고 버퍼 풀의 성능을 결정한다.
- `전체 더티 페이지 크기` < `리두 로그 파일 크기` 로 설정을 해야 한다.


[Redo log 선택적 활성/비활성]
> 데이터를 복구 or 대용량 데이터를 적재 시 잠깐 리두 로그를 비활성 하고 작업을 마친 뒤에 활성화를 할 수 있다.


<br>
<br>

---
## 어댑티브 해시 인덱스 AHI
> 스토리지 엔진에서 특정 인덱스가 자주 사용되면(자주 요청하는 데이터에 대해) 자동으로 해시 테이블을 생성해 `B Tree 인덱스 키 - Page 주소`쌍으로 저장하여  
> 인덱스 트리 탐색 없이 O(1)로 페이지를 찾을 수 있도록 한다.

- 스토리지 엔진 내 단 1개만 존재한다.
- 버퍼 풀에 적재된 데이터 페이지에 대해서만 해시 테이블을 관리하며 버퍼 풀에서 제거되면 해시 인덱스에서 삭제된다.
- 즉, **버퍼 풀과 생명주기가 같기 떄문에 디스크에 저장하지 않고, 메모리에서만 운용된다.**
- 하지만 하나의 메모리 객체라서 내부 락 경합이 크기 떄문에 -> `인덱스 파티션`을 적용해 완화한다.(기본 8개 파티션)


[AHI를 비효과적인 경우]
1. 디스크 읽기 많을떄 - 찾는 버퍼 풀에 없다는 얘기 이므로 AHI가 의미가 없음
2. 특정 패턴 쿼리 많을때 - `like문`, `조인 문`
3. 매우 큰 테이블의 레코드를 많이 읽은 경우 - 추후 재 조회 가능성이 떨어지므로 AHI가 의미가 없음

[AHI를 효과적인 경우]
1. 디스크의 데이터 양이 버퍼 풀 크기와 비슷
2. 동등비교 or In 비교 많을때
3. 쿼리 범위가 좁을때

> 정리하자면,  AHI의 사용이 항상 효과적인 것만은 아니다.  
> 디스크 탐색인 많은 DB는 AHI를 키면 오히려 성능이 안 좋다.  
> 또한 테이블 드랍 Alter 시 AHI에 있는 Page를 모두 제거해야 해서 스키마 변경시 성능이 떨어질 수 있따.

