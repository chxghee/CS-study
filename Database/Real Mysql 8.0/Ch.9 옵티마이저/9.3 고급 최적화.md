# 9.3 고급 최적화
> 옵티마이저는 쿼리의 실행 계획을 수립할 때 동계 정보와 사전 설정해둔 옵티마이저 옵션을 결합해 최적의 계획을 수립한다.

옵티마이저의 옵션은 크게
1. 조인 관련 옵션
2. 옵티마이저 스위치 옵션

두 개로 나눌 수 있따.
그중 옵티마이저 스위치 옵션들에 대해 알아 보자

<br>

## 옵티마이저 스위치 옵션
> `optimizer_switch` 시스텝 녓수에 여러게의 옵션을 세트로 묶어서 설정한다.

[스위치 옵션들]
| 옵티마이저 스위치 이름                  | 기본값 | 설명                                                  |
|------------------------------------|--------|-----------------------------------------------------|
| batched_key_access                 | off    | BKA 조인 알고리즘을 사용할지 여부 설정                 |
| block_nested_loop                  | on     | Block Nested Loop 조인 알고리즘을 사용할지 여부 설정   |
| engine_condition_pushdown          | on     | Engine Condition Pushdown 기능을 사용할지 여부 설정    |
| index_condition_pushdown           | on     | Index Condition Pushdown 기능을 사용할지 여부 설정     |
| use_index_extensions               | on     | Index Extension 최적화를 사용할지 여부 설정              |
| index_merge                        | on     | Index Merge 최적화를 사용할지 여부 설정                 |
| index_merge_intersection           | on     | Index Merge Intersection 최적화를 사용할지 여부 설정   |
| index_merge_sort_union            | on     | Index Merge Sort Union 최적화를 사용할지 여부 설정     |
| index_merge_union                  | on     | Index Merge Union 최적화를 사용할지 여부 설정          |
| mrr                                | on     | MRR 최적화를 사용할지 여부 설정                        |
| mrr_cost_based                     | on     | 비용 기반의 MRR 최적화를 사용할지 여부 설정            |
| semijoin                           | on     | 세미 조인 최적화를 사용할지 여부 설정                  |
| firstmatch                         | on     | FirstMatch 세미 조인 최적화를 사용할지 여부 설정       |
| loosescan                          | on     | LooseScan 세미 조인 최적화를 사용할지 여부 설정        |
| materialization                    | on     | Materialization 최적화를 사용할지 여부 설정            |
| subquery_materialization_cost_based | on     | 비용 기반의 Materialization 최적화를 사용할지 여부 설정|

설정은 다음과 같이 할 수 있다.

```sql
// 글로벌 설정
set global optimizer_switch='index_merge=on, index_merge_union=on...'

// 세션별 설정
set session optimizer_switch='index_merge=on, index_merge_union=on...' 
```

<br>
<br>

## MRR과 매치 키 억세스

기존 조인을 처리하는 일반적인 방식은 `네스티드 루프`방식을 사용한다.  
  ➡️ 드라이빙 레코드 건별로 드리븐 테이블의 레코드를 조인하는 방식  
  ➡️ 조인시 건 별 랜덤 I/O 가 발생하고 이는 스토리지 엔진에서 최적화가 불가하다.

- 때문에 최적화를 우 ㅣ해 드라이빙 테이블 레코드를 읽어 `조인 버퍼`에 버퍼링 하고,
- 조인 버퍼가 가득 차면 Mysql 엔진이 조인할 레코드를 스토리지 엔진에 `한번에 요청` 한다.  
  ➡️ 건별 랜덤 디스크 접근이 아니라, 한번에 순차 I/O 로 처리가 가능하다

이러한 방식을 `MRR`이라고 한다.

이러한 MRR 의 응용한 것이 스위치 설정의 `배치 키 억세스`라고 한다.

`batched_key_access` 조인 최적화는 기본적으로 비활성화 되어 있는데,  
레코드를 데이터 페이지에 정렬된 순서로 읽기 위해(순차 i/o) 조인 전, 부가적인 정렬작업이 필요하기 때문이다.



<br>
<br>

## 블록 네스티드 루프 조인
> 네스티드 조인 시 조인 버퍼를 이용해서 조인을 하는 설정이다.

- 일반적인 네스티드 조인은 드라이빙 테이블에서 레코드의 건수만큼 드리븐 테이블을 검색해서 처리한다.
  ➡️ 때문에 드라이빙이 1000개 레코드가 있따면, 드리븐에서 조인키에 대한 PK 인덱스나 세컨더리 인덱스가 없다면, 1000번의 풀 테이블 스캔을 해야 한다.

- 옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스를 탈 수 있게끔 실행 계획을 수립한다.

- 하지만 풀 테이블 스캔, 인덱스 풀 스캔을 피할 수 없다고 판단되면, 옵티마이저는 `조인 버퍼`에서 읽은 레코드를 캐싱하고,
- 이 캐싱된 데이터와 드리븐 테이블을 조인하는 형태로 처리한다.

```sql
select *
from dept_emp de, employee e
where de.from_date > '2000,10,10' and e.emp_no < 1000;
```
- 위와 같은 예시는 두 테이블 간 조인 조건이 없다 때문에 카테시안 조인을 수행하는데,
- 이떄  블록 네스티드 루프 조인이 사용된다.

<br>

[동작]

<img width="2000" height="1226" alt="image" src="https://github.com/user-attachments/assets/c330744d-681b-4cff-bdbf-f4b0882ec9c4" />

1. `dept_emp 테이블`의 fromdata인덱스를 통해 조건을 만족하는 레코드를 검색
2. 조인에 필요한 나머지 칼럼을 모두 `dept_emp 테이블`에서 읽어 조인 버퍼에 저장
3. `employee 태이블`의 프라이머리 키를 이용해 조건을 만족하는 레코드를 검색
4. 3번에서 검색된 레코드와 2번의 조인 버퍼를 결합해 반환




이렇게 동작하는데, 
이때 드리븐 이었던 `employee 태이블`이 드라이빙 테이블이 되고 `조인 버퍼`에 캐싱된 레코드들과 조인을 하므로,  
`from_date`기준의 정렬이 흐트러 질 수 있음을 주의해야 한다.

<br>
<br>

---

## 인덱스 컨디션 푸시 다운
> 인덱스 리프 노드에서 WHERE 조건을 먼저 필터링하여, 테이블 레코드를 가져오지 않아 디스크 접근을 줄이는 최적화 옵션이다.

```sql
select *
from emp
where last_name='Action' and first_name like '%sal'
```
인덱스가 (last_name, first_name) 이렇게 생성되었을때

위의 쿼리를 인덱스 컨디션 푸시 다운 설정을 껐을때와 켰을때를 비교해 보자


[설정 off]

<img width="531" height="276" alt="image" src="https://github.com/user-attachments/assets/99e7d7cd-a672-4584-9c06-5225ebaa792c" />

1. 첫 조건 last_name으로 인덱스를 타고 조회한다.
2. first_name은 조건은 `like '%sal'`이라 인덱스를 탈 수 없으므로 레코드를 직접 디스크에서 가져와 `sql엔진`이 비교를 한다. (필터링 조건으로 사용됨)


이때 만약 last_name 조건에 일치하는 레코드가 100만 건이고, 그중 first_name을 만족하는 레코드가 1건 이라면

단 1건을 위해 `employees` 테이블을 100만 번 풀 스캔을 해야 한다.

```
인덱스를 비교하는 작업는 innoDB 가 처리하고
테이블 레코드를 비교하는 작업은 sql엔진이 처리한다.

위의 상황에서는 first_name조건이 범위 제한 조건이 아니기 때문에
mysql 엔진이 first_name조건을 스토리지 엔진에 전달 해 주지 않아 인덱스를 통한 first_name 비교를 할 수 없었고,
실제 테이블 레코드에 접근해야 했다.
```

[설정 on]

<img width="526" height="274" alt="image" src="https://github.com/user-attachments/assets/38f5ecdb-6177-40ef-b347-5af5f22e4cc7" />

1. mysql 엔진이 first_name조건이 작업 범위 제한 조건이 아니더라도 스토리지 엔진으로 전달하여,
2.  인덱스 컨디션 푸시 다운 덕분에 인덱스 레벨에서 first_name조건을 필터링 할 수 있따.(실제 인덱스 팀색을 하는 것은 아님)

즉, 인덱스 리프 노드의 값을 읽고 거기서 조건을 비교하는 것이다.

때문에 웬만하면  `index_condition_pushdown=On` 설정을 해 주는 것이 좋다.

<br>
<br>

---
## 인덱스 확장 (use_index_extensions)
> 세컨더리 인덱스 리프 노드에 자동 포함된 PK 컬럼을 이용해, 추가적인 PK 인덱스 탐색 없이 데이터를 처리하는 최적화 옵션이다.


[예시 상황]

```sql
SELECT dept_no, emp_no, from_date
FROM dept_emp 
WHERE from_date = '1995-01-01' 
  AND dept_no = 'd005' 
  AND emp_no = 11000;
```

- `dept_emp` 테이블이 있을때 PK 가`(부서번호, 사번)` 이고, 세컨더리 인덱스가 `(from_date)`로 생성되어 있따면

- 세컨더리 인덱스 탐색은  
  1. (from_date) 인덱스로 탐색
  2. 리프 노드에서 PK(dept_no, emp_no) 얻음
  3. 다시 PK 인덱스 트리로 이동하여 full row 조회 (2번의 B-Tree 탐색 발생)
  위와 같은 순서로 `(from_date, 부서번호, 사번)`이러한 인덱스가 생성된 것처럼 인덱스 탐색이 이루어 질 것이다.

- 때문에 `use_index_extensions=on`을 해 주어 세컨더리 인덱스 탐색 시 2개의 인덱스를 탐색하지 않고,
- PK 인덱스를 덧붙여 `(from_date, 부서번호, 사번)`를 생성해 1번의 인덱스 트리 탐색으로 동작할 수 있도록 할 수 잇다.

[use_index_extensions = ON일 때 옵티마이저의 동작]
	•	옵티마이저는 마치 (from_date, dept_no, emp_no) 인덱스가 있는 것처럼 판단한다. (이떄 실제 인덱스를 만드는 것은 아니다.)
	•	이유는 이미 리프 노드에 PK가 있으니까 그걸로 조건을 전부 체크할 수 있기 때문이다.
	•	그래서 PK 인덱스 트리를 추가로 탐색하지 않고도 결과를 반환할 수 있음

만약 `select *`라면 실제 레코드를 가져와야 하므로 PK인덱스의 탐색이 필수적이다.
즉, 인덱스에 포함된 컬럼 만으로 쿼리 실행이 가능할 때 pk 인덱스 탐색없이 조회가 가능하다.

<br>
<br>

---
## 인덱스 머지 (index_merge)
