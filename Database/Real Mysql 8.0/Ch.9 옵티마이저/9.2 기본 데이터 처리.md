# 9.2 기본 데이터 처리
옵티마이저가 `정렬`과 `그룹핑`등 기본 데이터를 처리할 때 어떻게 실행 계획을 세우는지 알아보자.

<br>
<br>

## 테이블 풀 스캔과 인덱스 풀 스캔
옵티마이저가 쿼리를 실행할 때 위 두 가지 방식 중 무슨 상황에서 어떤 방식으로 데이터를 읽는 지 살펴 보자.

### 1. 옵티마이저가 테이블 풀 스캔을 선택하는 경우
- 테이블의 레코드 건수가 너무 적어 인덱스를 읽기보다 `테이블 풀 스캔`이 빠른 경우 (한 페이지 내에 모든 레코드가 들어있는 경우)

-  `where 절`이나 조인 시 `on 절`에 인덱스를 이용할 적절한 조건이 없을 때

-  인덱스 레인지 스캔이 가능해도 옵티마이저가 판단한 조건 일치 레코드가 너무 많을 거라고 예상한 경우  
   ➡️ 인덱스를 타고 데이터를 읽게 되면 레코드 건 별로 `랜덤 I/O` 가 발생하는데, 이럴 바에는 풀 스캔을 한다는 전략이다.

InnoDB에서는 테이블 풀 스캔시 디스크에서 여러 페이지들을 한번에 가져올수 있다.

이를 `Read Ahead`라고 한다.
```
디스크에서 특정 테이블의 연속된 페이지가 읽히게 되면...
-> 백그라운드 스레드가 자동으로 Read Ahead  작업
->  Read Ahead: 어떤 데이터가 필요해 질 것이라 예측해 미리 디스크를 읽어 버퍼 풀에 놓는 것
-> 즉, 풀 스캔시
  1. 처음 몇개의 페이지를 포그라운드 쓰레드가 디스크에서 읽어 옴
  2. 특점 시점 부턴 백그라운드가 읽기 작업
    -> 이떄 백그라운드는 리드 어헤드를 통해 한번에 읽는 페이지의 개수를 증가시키며 읽는다. (최대 64개)
```
이에 반해 MyISAM은 페이지를 1개씩 가져온다.

`innodb_read_ahead_threshold` 로 리드 어헤드를 시작하는 임계값을 설정할 수 잇다.

이러한 `Read Ahead` 는 인덱스 풀 스캔 시에도 사용된다.

<br>

###  1. 옵티마이저가 인덱스 풀 스캔을 선택하는 경우
다음의 쿼리에 대해 생각해 보자.
```sql
select count(*) from 테이블...
```
- 이때는 옵티마이저가 `인덱스 풀 스캔`을 사용해 쿼리를 처리한다.
- 아무런 조건이 없이 인덱스를 타지 않고 전체 레코드 개수를 조회하니 풀 테이블 스캔을 할 것 같지만...
- 옵티마이저는 여기서 단순히 레코드 건수만 필요하기 때문에, 용량이 작은 인덱스를 이용해 데이터를 읽음으로써 디스크 읽기 작업을 최소화 한다.

<br>
<br>

---
## 병렬처리
> 여기서 `병렬처리`의 의미는 하나의 쿼리를 여러 쓰레드가 작업을 나누어 동시에 처리하는 것을 말한다.

- `innodb_parallel_read_threads`로 설정할 수 있따.

- 8.0에서는 `where 절` 이 없는 전체 건수 조회`Count()` 에서만 쿼리를 여러 쓰레드로 병렬처리 할 수 있다.  
   (where 조건절이 있으면 쓰레드 별로 작업을 분할하고, 병합하는 처리가 복잡해 지기 떄문)


<br>
<br>

---
## 1. Order By 처리 (근데 이제 Filesort를 이용한..)
> 정렬을 처리하는 방법에는 `1. 인덱스를 이용한 방법`, `2. filesort를 이용한 방법` 두 가지가 있따.

정렬을 처리할 떄 인덱스를 이용하면,  
이미 정렬이 되어 있는 데이터를 순서대로 읽기만 하면 되니까 아주 베스트인 상황이라고 할 수 있다.

<br>

하지만 다음의 경우에는 인덱스를 통한 정렬을 할 수 없다.

[인덱스를 통한 정렬을 할 수 없는 경우]
1. 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
2. group by 의 결과 또는 distinct 같은 처리의 결과를 정렬해야 하는 경우
3. union 의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
4. 랜덤하게 결과 레코드를 가져와야 하는 경우
5. 인덱스와 정렬 순서가 다를 때(인덱스에 정의된 정렬 방향과 맞아야 함)
6. 정렬 조건이 WHERE 조건과 다른 인덱스를 사용할 때

위와 같은 상황이라면 `filesort`를 사용해야 한다.

| 구분              | 장점                                                                                    | 단점                                                                                                                                                  |
| --------------- | ------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| **인덱스 이용**      | - `INSERT`, `UPDATE`, `DELETE` 쿼리 실행 시 이미 인덱스가 정렬돼 있어 순서대로 읽기만 하면 되므로 매우 빠름           | - `INSERT`, `UPDATE`, `DELETE` 작업 시 **부가적인 인덱스 추가/삭제 작업** 필요하여 느림<br> - 인덱스 때문에 디스크 공간 더 많이 필요<br> - 인덱스의 개수가 늘어날수록 InnoDB의 **버퍼 풀을 위한 메모리**가 많이 필요 |
| **Filesort 이용** | - 인덱스를 생성하지 않아도 되므로 인덱스 단점을 회피<br> - 정렬할 레코드 수가 많지 않으면 **메모리에서 Filesort로 충분히 빠르게 처리** | - 정렬 작업이 쿼리 실행 시 처리되므로 **레코드 대상 건수가 많아질수록** 쿼리 응답 속도가 느림                                                                                            |


<br>
<br>

---
### Sort Buffer
> 정렬을 수행하기 위해 할당받는 별도 메모리 공간이다.

- 정렬해야 할 레코드 수에 따라 사용하는 공간의 크기는 가변적이고
- 쿼리 실행이 끝나면 바로 반납된다.
- 최대 사이즈가 정해져 있다.

<br>

#### Q. 정렬할 레코드 건수가 소트 버퍼가 할당 받을 수 있는 최대 사이즈보다 크다면?

```
-> 정렬할 레코드를 여러 조각으로 나누어 처리해야 한다.
-> 조각을 메모리의 소트 버퍼에 가져와 한 조각에 대해 정렬
-> 정렬한 조각을 디스크에 임시 저장
-> 다른 조각을 가져와 정렬 + 디스크 임시 저장 을 반복해야 한다.

이렇게 정렬된 임시저장 조각 끼리는 '멀티 웨이 머지 Alg'를 통해 전체 정렬된 결과를 반환한다.
(멀티 웨이 머지 Alg란 정렬된 각 조각의 맨 앞 을 비교하면서 병합하는 것이다.)
```

이렇게 소트 버퍼의 크기가 고정되어 있기 떄문에 임시 저장이 발생하고,
이때 디스크 접근이 발생해 성능상 많은 오버헤드가 발생한다.

<br>

#### Q. 그렇다면 큰 소트 버퍼를 설정하면 정렬 성능을 개선할 수 있을까?

```
항상 큰 소트 버퍼 크기를 설정하는 것이 좋은 영향을 주진 못한다.
-> 소트 버퍼는 메모리를 사용하기 때문에 많은 공간을 소트 버퍼에 할당하게 되면 다른 작업에 쓰일 메모리가 낭비 돼
   오히려 성능이 훨씬 떨어질 수 있다.
일반적으로 56KB ~ 1MB 로 설정하는 것이 좋다.
```

<br>

또 한 가지 주의해야 할 점은 소트 버퍼는 `세션 메모리 영역`에 위치한다.
- 때문에 여러 클라이언트가 공유해서 사용할 수 없어, 커넥션당 정렬작업이 발생시 메모리에 할당되고
- 많은 커넥션이 정렬 작업을 하면 메모리 공간의 사용이 엄청 늘어난다.
- 때문에 큰 소트 버퍼 설정은 메모리 부족으로 이어져
- 이때 많은 메모리를 사용하고 있는 Mysql 서버를 운영체제가 강제 종료할 수 도 있다.

  
<br>
<br>

---
### 정렬 알고리즘
> 레코드 들을 정렬할 때 레코드 전체를 소트 버퍼에 담아 정렬할지, 정렬 기준 컬럼만 담을지에 따라 `1. 싱글패스`와 `2. 투패스` 방식으로 나뉜다.

<br>

### 1. 싱글패스 정렬 방식
- select의 조회 대상이 되는 모든 컬럼을 소트 버퍼에 담아 정렬한다.
- 모드는 컬럼을 가져와 정렬을 하기 떄문에 소트 버퍼에 담을 수 있는 레코드가 적다 -> 디스크 접근 많이 발생

<br>

### 2. 투 패스 정렬 방식
- 대상 컬럼과 pk 키 값만 소트 버퍼에 담아 정렬
- 정렬된 순서대로 pk 값을 통해 테이블을 읽어 최종 select 결과 반환
- 즉, 테이블을 2번 읽어야 한다

투패스는 테이블을 2번 읽어야 하기 때문에,  보통 조회 쿼리는 소트 버퍼 메모리를 많이 사용하긴 하지만 싱글패스 방식을 사용한다.

<br>
하지만 다음의 경우에는 옵티마이저가 투 패스를 사용한다.
[투 패스를 사용하는 경우]
1. 레코드 크기가 `max_length_for_sort_data` 설정변수보다 클때
2. `BLOB`타입이나 `TEXT`타입의 컬럼을 조회할 떄 


싱글패스는 조회 레코드가 적거나 크기가 작을 때 좋은 성능을 보이고,  
투패스는 크기와 건수가 많을 때 비교적 성능을 개선할 수 있다.

옵티마이저는 보통 싱글 패스 전략을 사용하므로 정렬이 필요한 select 쿼리시, 적절히 projection 시켜 조회하면 메모리를 절약 할 수 있다.

<br>
<br>

### 정렬 처리 방법
> 쿼리에서 `order by`가 사용되면 다음 3가지의 방법 중 하나로 정렬이 처리된다.

1. 인덱스를 이용한 정렬
2. 조인에서 드라이빙 테이블을 정렬한 뒤 조인 - using file sort
3. 조인을 한 뒤 결과를 임시 테이블에 저장 후 정렬 - using temporary: using file sort

아래로 내려갈 수록 처리 속도가 느려지기 때문에

옵티마이저는 1,2,3 의 순서대로 가능한지 판단한 다음 불가능 하면 후순위의 방식으로 정렬을 수행한다.

<br>
<br>

### 1. 인덱스를 이용한 정렬
> 인덱스를 이용한 정렬은 인덱스를 타고 순서대로 읽으면 되므로, 별도의 file sort가 필요 없다.

<br>

[인덱스 정렬을 사용하기 위한 조건]
1. order by 컬럼이 제일 먼저 읽는 테이블에 속해야 한다. (조인인 경우 드라이빙 테이블이여야 함)

2. order by의 순서대로 생성된 인덱스가 필요하다.
   
3. where 절에 첫 번째로 읽는 테이블의 컬럼 조건이 있다면, 그 조건과 order by 절은 같은 인덱스를 사용 할 수 있어야 한다.
   (where 절과 order by 절이 같은 인덱스를 사용해서 처리가 가능해야 함)

4. b-tree 계열 인덱스만 가능하다. (해시, 전문 검새.. x)

5. 여러 테이블이 조인 되는 경우, `네스티드 루프` 방식의 조인만 정렬처리가 가능하다.

<br>

여기서 `네스티드 루프`란 왼쪽 테이블의 레코드에 대해 다른 조인되는 테이블을 반복 탐색하면서 조인 조건에 맞는 컬럼을 조인하는 가장 기본적인 조인 방식이다.

때문에 네스티드 루프는 드라이빙 테이블의 인덱스 읽기 순서가 흐트러 지지 않기 때문에 인덱스를 통한 정렬을 사용할 수 있다.


<br>
<br>

### 2. 조인에서 드라이빙 테이블을 정렬한 뒤 조인
 조인을 한 뒤 정렬하념, 레코드의 건수와 크기가 기하급수적으로 증가하기 때문에 조인을 처리하기 전에 기준이 되는 드라이빙 테이블을 정렬한 뒤 조인을 처리하는 방식이다.

 위 방식을 사용하기 위해서는,   
조인에서 첫 번쨰로 읽히는 드라이빙 테이블의 컬럼만으로 order by 가 이루어 져야 한다.

<br>
옵티마이저는 조인 족ㄴ을 만족하는 레코드를 가장 빨리 줄일 수 있는 테이블을 `드라이빙 테이블`로 선택한다.

```sql
select *
from 직원 e, 급여 s
where e.사번 = s.사번
   and e.사번 between 1000 and 2000
order by e.last_name
```
- 여기선 where 절의 e.사번 의 `between` 조건으로 레코드를 빨리 줄일 수 있으니  직원 테이블이 드라이빙 테이블이 된다.
- 드리븐 테이블의 조인 칼럼인 사번 컬럼에 인덱스가 존재한다.

위의 이유 때문에 옵티마이저는 직원테이블을 드라이빙 테이블로 선택한다.

[조회 과정]
1. `e.사번 between 1000 and 2000` 을 통해 만족하는 레코드 10건을 조회
2. 검색 결과를 소트 버퍼를 이용해 last_name 기준으로 정렬 (file sort)
3. 소트 버퍼의 정렬된 결과를 순서대로 읽으면서 급여 테이블과 조인을 수행

이때 `last_name`은 드라이빙 테이블인 직원 테이블에 속한 컬럼이므로 정렬 후 조인을 수행할 수 있었다.


<br>
<br>
### 3.  임시 테이블을 이용한 정렬
> 조인 결과를 임시 테이블에 저장하고 정렬한다.



```sql
select *
from 직원 e, 급여 s
where e.사번 = s.사번
   and e.사번 between 1000 and 2000
order by e.연봉
```
- 위와 같이 드리븐 테이블의 컬럼이 정렬 조건이면, .
- 조인을 진행한 뒤, 결과를 임시 테이블에 저장하고
- 정렬을 수행해야 한다.



<br>
<br>
---
### 정렬 처리 방법의 성능 비교
인덱스를 사용하지 못하는 정렬, 그루핑이 왜 느려지는지 살펴 보자

### 1. 스트리밍 처리 방식
> 서버가 처리한 데이터 양아 얼마인지 관계없이 조건에 일치한 레코드가 검색 될 때마다 바로바로 클라이언트에 결과를 전송하는 방식이다.

- 쿼리 요청후 바로 결과의 첫 레코드를 빠르게 리턴받을 수 있어 `빠른 응답속도`를 기대 할 수 있다.  
  (때문에 웹 서버에서는 쿼리 요청의 데이터를 리턴받는 중에 동시에 데이터를 가공해서 클라이언트에 빠르게 응답할 수 있다.)
- limit 같은 건수 제한 쿼리의 전체 실행 시간을 상당히 줄여준다.


<br>

### 2. 버퍼링 처리 방식
> 정렬 및 그루핑 처리는 쿼리 결과를 바로바로 스트리밍 할 수 없으므로(레코드를 가져와 정렬, 그루핑을 해야 하기 때문) 이를 버퍼링 처리 방식이라 한다.

예외로 인덱스를 이용한 정렬 방식은 읽는 순서대로 응답할 수 있으므로, 스트리밍 처리되어 빠르게 응답한다.


<br>
<br>
---
## 2. Group By 처리

### 인덱스를 이용한 Group by처리

### 1. 인덱스 스캔을 이용하는 그루핑(타이트 인덱스 스캔)
- 조인의 드라이빙 테이블에 속한 컬럼만으로 그루핑을 할때 해당 컬럼의 인덱스가 있다면,
- 인덱스를 차례로 읽으며 그루핑을 한 뒤, 조인을 진행한다.
- 이미 정렬되어 있는 인덱스를 순서대로 읽어 그루핑을 하므로 정렬이나, 별도의 임시 테이블이 필요 없다.

하지만 인덱스로 그루핑 되어도, `MIN MAX`이외의 집계 함수를 사용하면 임시 테이블이 필요할 수 있다.

<br>

### 2.  루스 인덱스 스캔을 통한 그루핑


인덱스가 (사번, 수령일자) 로 생성된 상황에서 다음의 쿼리를 살펴보자
```sql
select 사번
from 급여
where 수령날짜 = '2000-10-10'
group by 사번;
```

- (사번, 수령일자) 인덱스를 살펴 보면서 사번의 첫 번째 유일한 값인 10번을 찾는다.
- (사번, 수령일자) 인덱스에서 사번이 10인 것들 중에서 `수령날짜 = '2000-10-10'` 인 레코드만 인덱스를 통해 순서대로 가져온다 = `루스 인덱스 스캔`
- 1,2를 반복한다.

<br>
[유의사항]
- 루스 인덱스 스캔을 이용한 그루핑은 단일 테이블에서만 적용가능하다.
- 유니크한 값이 적을 수록 성능이 좋아진다.
- `MIN MAX`이외의 집계 함수를 사용하면 루스 스캔 x
- 그룹 바이의 컬럼의 순서가 인덱스의 순서와 다를 때 루스 스캔 x
- select 절의 컬럼이 그룹 바이와 일치하지 않을 때 루스 스캔 x


[그루핑 시 루스 인덱스 스캔이 가능한 쿼리]
```sql
SELECT col1, col2 FROM tb_test GROUP BY col1, col2;

SELECT DISTINCT col1, col2 FROM tb_test;

SELECT col1, MIN(col2) FROM tb_test GROUP BY col1;

SELECT col1, col2 FROM tb_test WHERE col1 < const GROUP BY col1, col2;

SELECT MAX(col3), MIN(col3), col1, col2 FROM tb_test WHERE col2 > const GROUP BY col1, col2;

SELECT col2 FROM tb_test WHERE col1 < const GROUP BY col1, col2;

SELECT col1, col2 FROM tb_test WHERE col3 = const GROUP BY col1, col2;
```

<br>
<br>


### 임시 테이블을 이용하는 그루핑
> 그루핑을 하는 경우 내부적으로 group by 컬럼들로 구성된 `유니크 인덱스를 가진 임시 테이블`을 만들어 중복 제거와 집합함수 연산을 실행한다.

조인도 같이 하는 경우, 조인 결과를 한 건씩 가져와 임시 테이블에 중복 체크를 하면서 insert 한다.(이때 만들어진 유니크 인덱스를 이용한다.)



<br>
<br>

---
## 3. DISTINCT 처리
> DISTINCT는 유니크한 레코드만 가져와야 하므로 옵티마이저는 DISTINCT 처리를 group by와 같은 방식으로 처리한다.

즉, GROUP BY처럼 각 고유한 컬럼 조합을 그룹핑해서 하나만 남기는 방식으로 처리한다

집합 함수와 같이 DISTINCT가 사용되는 경우에는 인덱스를 사용하지 못하므로 항상 임시 테이블이 필요하다.  
(중복을 제거한 결과 집합을 만든 후 → 집계 연산을 해야 하기 때문이다.)


<br>

### 집합 함수와 같이 사용된 DISTINCT
- count(), min, max 와 같은 집합함수에서 DISTINCT가 사용되면, 우선 DISTINCT의 인자로 전달된 컬럼 값이 유니크한 것들만 가져와 함수를 처리한다.

```sql
select count( distinct s.급여)
from 직원 e, 급여 s
where e.사번 =  s.사번
   and e.사번 between 100 and 200
```
- 위 쿼리에서는 `count( distinct s.급여)`를 처리하기 위해 임시 테이블이 생성된다.
- 급여에 대해서는 인덱스가 생성되어 있지 않으므로 distinct처리를 위해서는 임시 테이블을 생성해야 한다.
- 이떄 생성되는 임시 테이블은 두 테이블을 조인한 결과에서 급여 컬럼의 값만 저장히기 위한 임시테이블을 만든다. (distinct를 위해 급여 컬럼에 유니크 인덱스를 생성한 임시 테이블을 만든다.)


<br>
<br>

---

## 4. 내부적 임시 테이블 활용
> mysql 엔진이 스토리지 엔진에서 받아 온 레코드를 정렬 하거나 그루핑 할때 내부 임시 테이블을 사용해 처리한다.

- 내부 임시 테이블은 메모리에 생성되었다가 크기가 커지면 디스크로 옮겨지게 된다.
- 쿼리의 처리가 완료되면 자동으로 삭제된다.

<br>
### 메모리 임시 테이불과 디스크 임시 테이블
메모리 임시 테이불에는 `TempTable 스토리지 엔진`이 사용되고.
디스크 임시 테이블은 `InnoDB 스토리지 엔진` 을 사용한다. 

메모리의 임시 테이블이 1GB 보다 커지면 InnDB가 디스크에 저장한다.

[디스크 저장 방식]
1. MMAP파일로 기록
2. InnoDB 테이블로 기록

이때 메모리에 생성되었다가 디스크로 옮겨지는 임시 테이블은 기본적으로 MMAP 방식으로 저장되고,  
메모리를 거치지 않고 바로 디스크에 써지는 임시 테이블은 InnoDB 테이블 방식으로 저장된다.


<br>
### 임시 테이블이 필요한 쿼리
> 임시 테이블이 필요한 경우는 조회시 가져온 레코드가 별도의 가공처리가 필요할때 임시테이블을 사용한다.

물론, 별도 가공 처리(정렬, 그루핑, 집계함수...등)가 필요할 떄 인덱스를 사용할 수 있다면, 임시 테이블을 생성하 필요가 없다.

[임시 테이블이 필요한 쿼리]
| 번호 | 상황                                                                 | 설명                                                                 |
|------|----------------------------------------------------------------------|----------------------------------------------------------------------|
| 1    | `ORDER BY`, `GROUP BY`에 명시된 컬럼이 SELECT된 컬럼과 달라 인덱스를 쓸 수 없는 경우 | ✅ 인덱스를 사용하지 못해 임시 테이블 + filesort 필요                |
| 2    | `ORDER BY`, `GROUP BY` 대상이 조인의 첫 번째 테이블의 컬럼이 아닌 경우       | ✅ 조인 결과로 정렬 or 그룹화해야 하므로 임시 테이블 생성             |
| 3    | `DISTINCT`와 `ORDER BY`가 동시에 사용된 경우                          | ✅ 정렬 + 중복 제거를 위해 임시 테이블 필요                          |
| 4    | `DISTINCT`가 인덱스로 커버되지 못하는 경우                            | ✅ 임시 테이블에서 중복 제거                                          |
| 5    | `UNION`, `UNION DISTINCT` 사용된 쿼리                                 | ✅ 서브쿼리 결과를 합치기 위한 임시 테이블 생성                       |
| 6    | `select_type`이 `DERIVED` (파생 테이블, 즉 FROM 절 서브쿼리)인 경우         | ✅ 서브쿼리 결과를 materialize → 임시 테이블로 만듦                  |



