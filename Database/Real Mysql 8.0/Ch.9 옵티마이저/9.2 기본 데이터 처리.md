# 9.2 기본 데이터 처리
옵티마이저가 `정렬`과 `그룹핑`등 기본 데이터를 처리할 때 어떻게 실행 계획을 세우는지 알아보자.

<br>
<br>

## 테이블 풀 스캔과 인덱스 풀 스캔
옵티마이저가 쿼리를 실행할 때 위 두 가지 방식 중 무슨 상황에서 어떤 방식으로 데이터를 읽는 지 살펴 보자.

### 1. 옵티마이저가 테이블 풀 스캔을 선택하는 경우
- 테이블의 레코드 건수가 너무 적어 인덱스를 읽기보다 `테이블 풀 스캔`이 빠른 경우 (한 페이지 내에 모든 레코드가 들어있는 경우)

-  `where 절`이나 조인 시 `on 절`에 인덱스를 이용할 적절한 조건이 없을 때

-  인덱스 레인지 스캔이 가능해도 옵티마이저가 판단한 조건 일치 레코드가 너무 많을 거라고 예상한 경우  
   ➡️ 인덱스를 타고 데이터를 읽게 되면 레코드 건 별로 `랜덤 I/O` 가 발생하는데, 이럴 바에는 풀 스캔을 한다는 전략이다.

InnoDB에서는 테이블 풀 스캔시 디스크에서 여러 페이지들을 한번에 가져올수 있다.

이를 `Read Ahead`라고 한다.
```
디스크에서 특정 테이블의 연속된 페이지가 읽히게 되면...
-> 백그라운드 스레드가 자동으로 Read Ahead  작업
->  Read Ahead: 어떤 데이터가 필요해 질 것이라 예측해 미리 디스크를 읽어 버퍼 풀에 놓는 것
-> 즉, 풀 스캔시
  1. 처음 몇개의 페이지를 포그라운드 쓰레드가 디스크에서 읽어 옴
  2. 특점 시점 부턴 백그라운드가 읽기 작업
    -> 이떄 백그라운드는 리드 어헤드를 통해 한번에 읽는 페이지의 개수를 증가시키며 읽는다. (최대 64개)
```
이에 반해 MyISAM은 페이지를 1개씩 가져온다.

`innodb_read_ahead_threshold` 로 리드 어헤드를 시작하는 임계값을 설정할 수 잇다.

이러한 `Read Ahead` 는 인덱스 풀 스캔 시에도 사용된다.

<br>

###  1. 옵티마이저가 인덱스 풀 스캔을 선택하는 경우
다음의 쿼리에 대해 생각해 보자.
```sql
select count(*) from 테이블...
```
- 이때는 옵티마이저가 `인덱스 풀 스캔`을 사용해 쿼리를 처리한다.
- 아무런 조건이 없이 인덱스를 타지 않고 전체 레코드 개수를 조회하니 풀 테이블 스캔을 할 것 같지만...
- 옵티마이저는 여기서 단순히 레코드 건수만 필요하기 때문에, 용량이 작은 인덱스를 이용해 데이터를 읽음으로써 디스크 읽기 작업을 최소화 한다.

<br>
<br>

---
## 병렬처리
> 여기서 `병렬처리`의 의미는 하나의 쿼리를 여러 쓰레드가 작업을 나누어 동시에 처리하는 것을 말한다.

- `innodb_parallel_read_threads`로 설정할 수 있따.

- 8.0에서는 `where 절` 이 없는 전체 건수 조회`Count()` 에서만 쿼리를 여러 쓰레드로 병렬처리 할 수 있다.  
   (where 조건절이 있으면 쓰레드 별로 작업을 분할하고, 병합하는 처리가 복잡해 지기 떄문)


<br>
<br>

---
## Order By 처리 (근데 이제 Filesort를 이용한..)
> 정렬을 처리하는 방법에는 `1. 인덱스를 이용한 방법`, `2. filesort를 이용한 방법` 두 가지가 있따.

정렬을 처리할 떄 인덱스를 이용하면,  
이미 정렬이 되어 있는 데이터를 순서대로 읽기만 하면 되니까 아주 베스트인 상황이라고 할 수 있다.

<br>

하지만 다음의 경우에는 인덱스를 통한 정렬을 할 수 없다.

[인덱스를 통한 정렬을 할 수 없는 경우]
1. 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
2. group by 의 결과 또는 distinct 같은 처리의 결과를 정렬해야 하는 경우
3. union 의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
4. 랜덤하게 결과 레코드를 가져와야 하는 경우
5. 인덱스와 정렬 순서가 다를 때(인덱스에 정의된 정렬 방향과 맞아야 함)
6. 정렬 조건이 WHERE 조건과 다른 인덱스를 사용할 때

위와 같은 상황이라면 `filesort`를 사용해야 한다.

| 구분              | 장점                                                                                    | 단점                                                                                                                                                  |
| --------------- | ------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| **인덱스 이용**      | - `INSERT`, `UPDATE`, `DELETE` 쿼리 실행 시 이미 인덱스가 정렬돼 있어 순서대로 읽기만 하면 되므로 매우 빠름           | - `INSERT`, `UPDATE`, `DELETE` 작업 시 **부가적인 인덱스 추가/삭제 작업** 필요하여 느림<br> - 인덱스 때문에 디스크 공간 더 많이 필요<br> - 인덱스의 개수가 늘어날수록 InnoDB의 **버퍼 풀을 위한 메모리**가 많이 필요 |
| **Filesort 이용** | - 인덱스를 생성하지 않아도 되므로 인덱스 단점을 회피<br> - 정렬할 레코드 수가 많지 않으면 **메모리에서 Filesort로 충분히 빠르게 처리** | - 정렬 작업이 쿼리 실행 시 처리되므로 **레코드 대상 건수가 많아질수록** 쿼리 응답 속도가 느림                                                                                            |


<br>
<br>

---
### Sort Buffer
> 정렬을 수행하기 위해 할당받는 별도 메모리 공간이다.

- 정렬해야 할 레코드 수에 따라 사용하는 공간의 크기는 가변적이고
- 쿼리 실행이 끝나면 바로 반납된다.
- 최대 사이즈가 정해져 있다.

<br>

#### Q. 정렬할 레코드 건수가 소트 버퍼가 할당 받을 수 있는 최대 사이즈보다 크다면?

```
-> 정렬할 레코드를 여러 조각으로 나누어 처리해야 한다.
-> 조각을 메모리의 소트 버퍼에 가져와 한 조각에 대해 정렬
-> 정렬한 조각을 디스크에 임시 저장
-> 다른 조각을 가져와 정렬 + 디스크 임시 저장 을 반복해야 한다.

이렇게 정렬된 임시저장 조각 끼리는 '멀티 웨이 머지 Alg'를 통해 전체 정렬된 결과를 반환한다.
(멀티 웨이 머지 Alg란 정렬된 각 조각의 맨 앞 을 비교하면서 병합하는 것이다.)
```

이렇게 소트 버퍼의 크기가 고정되어 있기 떄문에 임시 저장이 발생하고,
이때 디스크 접근이 발생해 성능상 많은 오버헤드가 발생한다.

<br>

#### Q. 그렇다면 큰 소트 버퍼를 설정하면 정렬 성능을 개선할 수 있을까?

```
항상 큰 소트 버퍼 크기를 설정하는 것이 좋은 영향을 주진 못한다.
-> 소트 버퍼는 메모리를 사용하기 때문에 많은 공간을 소트 버퍼에 할당하게 되면 다른 작업에 쓰일 메모리가 낭비 돼
   오히려 성능이 훨씬 떨어질 수 있다.
일반적으로 56KB ~ 1MB 로 설정하는 것이 좋다.
```

<br>

또 한 가지 주의해야 할 점은 소트 버퍼는 `세션 메모리 영역`에 위치한다.
- 때문에 여러 클라이언트가 공유해서 사용할 수 없어, 커넥션당 정렬작업이 발생시 메모리에 할당되고
- 많은 커넥션이 정렬 작업을 하면 메모리 공간의 사용이 엄청 늘어난다.
- 때문에 큰 소트 버퍼 설정은 메모리 부족으로 이어져
- 이때 많은 메모리를 사용하고 있는 Mysql 서버를 운영체제가 강제 종료할 수 도 있다.

  
<br>
<br>

---
### 정렬 알고리즘
