# 5.4 트랜잭션 격리 수준
> 트랜잭션이 동시에 처리 될 때 다른 트랜잭션에서 변경/삽입 되는 데이터 읽기를 허용할지를 결정하는 설정이다.

<img width="764" height="213" alt="image" src="https://github.com/user-attachments/assets/804b29e5-3dd8-4681-a2f9-310b4ff3005b" />

위와 같이 4가지의 레벨이 있으며,
아래로 내려갈수록 고립성은 올라가고, 동시처리 성능은 떨어진다.

또한 서로 다른 트랜잭션이 값을 수정할 떄 마지막으로 수정한 값으로 덮어 씌어지는 `Lost Update`는 SERIALIZABLE 레벨을 제외한 모든 레벨에서 발생한다.
따라서 이러한 경우에는 동시요청시 프로그램 코드에서 적절하게 락을 활용하여 데이터 정합성을 보장해야 한다.



<br>
<br>

---
## READ UNCOMMITTED
> 각 트랜잭션의 변경 내용이 커밋 여부와 상관없이 다른 트랜잭션에서 조회가 가능한 격리 수준

<img width="974" height="902" alt="image" src="https://github.com/user-attachments/assets/56ecab97-cc29-4361-ab1f-998b0fd1ed39" />

- 위와 같이 사용자 A가 새로 insert한 내용이 커밋되지 않았지만, 사용자 B에서 조회할 수 있다.

위와 같은 현상을 `Dirty Read`라고 한다.


<br>
<br>

---
## READ COMMITTED
> 트랜잭션은 커밋된 내용만 읽을 수 있어 더티 리드가 발생하지 않는 격리 수준

<img width="984" height="920" alt="image" src="https://github.com/user-attachments/assets/098b185f-3afa-4307-ac71-52ce91e3b3d1" />


- 오라클 DB에서 기본을 사용하는 옵션 (대부분의 DBMS가 기본값으로 채택하였다.)
- 다른 트랜잭션이 중간에 값을 읽을 때 이전 언두로그에 기록된
- 데이터 변경 발생 시 언두 로그에 이전 레코드 정보가 백업된다.
- 따라서 사용자 A가 데이터를 변경한 후 중간에 사용자 B가 해당 컬럼을 조회하면 언두 로그에 백업된 레코드를 조회한다.


[NON REPEATABLE READ 문제]
<img width="1026" height="888" alt="image" src="https://github.com/user-attachments/assets/8d3704b9-0e9e-40b5-b07d-a070faa321cd" />

- 위와 같이 사용자 B 트랜잭션이 동일한 내용을 조회할 때
- 사용자 A 트랜잭션이 중간에 값을 수정한 뒤 커밋을 하면, 같은 내용을 조회 했지만 다른 결과가 보이게 된다.


또한 팬텀 리드가 발생할 수 있다.


<br>
<br>

---
## REPEATABLE READ
> 트랜잭션 시작 시점에 언두로그 스냅샷을 기준으로 데이터를 읽어 일관된 읽기를 지원하는 격리 수준


- InnoDB에서 기본 설정
- MVCC를 이용해서 트랜잭션 시작 시점의 언두 로그 스냅샷으로 값을 조회하는 방식이다.
- READ COMMITTED과의 결정적인 차이는 참조하는 언두 로그의 여러 버전 중 몇번쨰 언두 로그를 참조하느냐에 있다.

<img width="1100" height="1146" alt="image" src="https://github.com/user-attachments/assets/068587a9-9f15-49b7-94cf-2bab770835b2" />

- 사용자 B가 트랜잭션을 시작하면 트랜잭션 번호가 부여됨 (10번)  
- 언두 로그에는 트랜잭션 번호를 포함하고 있기 때문에 10번 보다 앞선 트랜잭션 번호를 가진 언두 로그를 참조한다.  

이떄 주의할 점은 트랜잭션이 길어질 수록 언두 영역에 백업된데이터의 양이 많아지기 때문에 서버 전체의 처리성능이 떨어질 수 있다.  

<br>

[팬텀리드 문제]
<img width="1104" height="1042" alt="image" src="https://github.com/user-attachments/assets/2ff63b95-619d-4c73-a936-4c2ae19d1d94" />

- 사용자 B 는 `select for update`문으로 읽은 레코드에 대해 락을 걸었다.
- 중간에 사용자 A는 기존 데이터의 수정이 아닌 새로운 데이터를 삽입하고 커밋했다.
- 새로 커밋된 데이터에 대해서는 언두 로그에 기록이 되지 않을 뿐더러, 락의 대상도 되지 않기 때문에 다시 조회시 해당 데이터가 조회되게 된다.

```
언두로그에는 기존에 있었던 레코드의 '변경이력'만 수냅샷으로 저장하는데,
새롭게 insert된 레코드는 언두 로그에 저장할 수 없어 재 조회시 새로운 값이 포함된다.
```

- 팬텀리드는 SERIALIZABLE을 제외한 모든 격리 수준에서 발생할 수 있다.
- 하지만 InnoDB를 사용하는 Mysql에서는 갭락과 넥스트 키 락으로 팬텀리드를 방지할 수 있따.


<br>
<br>

---
## SERIALIZABLE
> 읽기 시에도 S-lock(공유락)을 걸어 다른 트랜잭션에서 데이터의 변경을 막아 모든 동시성 문제들을 차단하는 격리 수준

- 때문에 모든 트랜잭션이 순차적으로 실행되어 위에서 발생할 수 있는 모든 문제들이 발생하지 않는다
- 하지만 높은 격리성으로 동시 처리 성능이 매우 떨어지게 된다
