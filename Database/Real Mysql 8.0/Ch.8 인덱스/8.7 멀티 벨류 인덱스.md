# 8.7 멀티 벨류 인덱스

## 멀티 밸류 인덱스(Multi-Value Index, MVI)란?

> JSON 배열, ARRAY 등 하나의 컬럼에 여러 값이 들어가는 다중값 데이터를  
→ 하나의 인덱스에서 각각 키로 관리할 수 있는 인덱스


--- 
## GPT 요약 내용

✅ “하나의 레코드가 여러 인덱스 키를 가진다”는 뜻

예를 들어

tags = ["java", "mysql", "spring"]

이런 JSON 배열을 저장했다고 해볼게요.

멀티 밸류 인덱스를 설정하면
	•	이 한 레코드(row) 에 대해
→ java
→ mysql
→ spring
이 각각 별도의 인덱스 키 로 저장됩니다.

즉
	•	같은 PK를 가진 레코드인데
	•	인덱스 상에서는
	•	(java, PK)
	•	(mysql, PK)
	•	(spring, PK)
세 개의 엔트리를 따로 등록하는 식입니다.

⸻

✅ 왜 필요하냐?

예전에는
	•	JSON 배열에 “mysql”이 들어있다고 해도
→ 배열 내부 값 기준으로 인덱스를 만들 수 없어서
→ JSON_CONTAINS 같은 함수로 풀스캔만 가능

하지만
	•	멀티 밸류 인덱스는
→ 배열의 각 항목을 별도의 인덱스 키로 만들어 주기 때문에
→ JSON 안의 특정 요소 검색도 빠르게 수행 가능

⸻

✅ 쉽게 예를 들어

예를 들어

```sql
CREATE TABLE post (
  id BIGINT PRIMARY KEY,
  tags JSON,
  INDEX idx_tags((CAST(tags AS CHAR ARRAY)))
);
```

이렇게 하면
	•	한 레코드의 tags에

["mysql", "spring", "java"]

가 들어가면

	•	인덱스에는
	•	키 = mysql, 값 = id
	•	키 = spring, 값 = id
	•	키 = java, 값 = id
이렇게 3개의 인덱스 키 로 등록되지만
→ 실제로는 한 레코드(row)를 가리키죠.

⸻

✅ 다시 말해
	•	하나의 레코드
→ 여러 배열 원소를 가지고 있음
→ 각각을 인덱스 키로 분리
	•	결국 인덱스만 여러 엔트리가 생긴다, 레코드는 하나다

👉 그래서 하나의 레코드 = 여러 인덱스 키 엔트리 라고 표현하는 겁니다.

⸻

✅ 요약
	•	멀티밸류 인덱스 = 배열/JSON/다중값 컬럼을 인덱스에 “각 원소별로” 키로 등록
	•	같은 레코드를 가리키지만
→ 인덱스에는 여러 엔트리가 생성됨



⸻

✅ 왜 이게 이득이냐?

우선 JSON 배열을 생각해볼게요:

["mysql", "spring", "java"]

이 배열이 들어 있는 컬럼을 예를 들어 tags 라고 하고,
우리가 쿼리에서

```sql
SELECT * FROM post WHERE JSON_CONTAINS(tags, '"mysql"');
```
라고 한다면,

인덱스가 없으면
	•	JSON 안을 모든 레코드를 다 뒤져서
→ 하나씩 JSON 파싱
→ “mysql” 이 포함됐는지 풀스캔
→ 엄청 느림

⸻

✅ 멀티밸류 인덱스를 쓰면

멀티밸류 인덱스는
	•	tags 컬럼을 분해해서
	•	mysql → 인덱스 키
	•	spring → 인덱스 키
	•	java → 인덱스 키
→ 각각을 인덱스의 엔트리로 만들어 둡니다.

즉
	•	mysql → 해당 row PK
	•	spring → 해당 row PK
	•	java → 해당 row PK

이렇게 인덱스에 따로따로 등록되어 있으니
→ mysql 을 찾으면 바로 인덱스 탐색만으로
→ 이 row의 PK 를 빠르게 찾을 수 있음

⸻

✅ 핵심 장점

✅ 다중값(배열) 안의 한 요소만으로도 인덱스 탐색 가능
→ JSON_CONTAINS 나 배열 포함 조건 같은 쿼리의 속도가
→ 비교 불가능할 만큼 빨라진다 는 게 최대 이득이에요.

⸻

✅ 비유로 말하면

한 레코드가 “java, spring, mysql” 3개의 태그를 가지고 있으면
그 레코드를 3개의 별도 색인(색인표)에 등록해두는 것

그래서
	•	“mysql 찾고 싶다”
→ 색인표에서 mysql 항목만 찾으면 바로 그 레코드
	•	“spring 찾고 싶다”
→ spring 항목만 인덱스로 바로 찾음

이렇게 되어
JSON 배열 안에 어떤 값이 있더라도 매우 빠르게 찾을 수 있게 됩니다.

⸻

✅ 요약
	•	JSON 배열에 여러 값이 들어 있어도
	•	각 값마다 인덱스 엔트리를 만들어 등록
	•	쿼리가 그 중 하나의 값만 필요할 때도
→ 바로 인덱스 탐색 가능
→ 풀스캔·JSON 파싱 없이 처리 가능
