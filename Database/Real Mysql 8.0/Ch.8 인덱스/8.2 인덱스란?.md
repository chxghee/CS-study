# 8.2 인덱스란?
> 컬럼의 값과 레코드가 저장된 페이지 주소를 키-값 쌍의 인덱스를 만들어 빨리 디스크 내 위치하는 데이터를 찾을 수 있도록 한다

즉 인덱스는 책 맨 뒷장의 찾아보기로 비유 할 수 있다.

이때 가장 중요한 점은 칼럼의 값을 주어진 순서대로 **정렬**해서 인덱스로 저장한 다는 것이다.
이렇게 칼럼 값을 기준으로 정렬된다면 더욱 빠르게 해당 인덱스를 찾을 수 있다.

즉 DBMS는 인덱스를 저장하는 자료구조로 `SortedList`와 같은 순서를 유지하는 자료구조를 사용하고
데이터 파일은 `ArrayList`와 같은 저장 순서를 유지하는 자료구조를 사용한다고 이해하면 쉽다.

```
하지만 데이터 파일에서는 항상 들어온 순서대로 저장되지는 않는다
왜냐하면 특정 페이지를 삭제 한다면 해당 페이지에 새로운 데이터를 덮어 쓰는 방식을 사용하기 떄문에 순서가 보장되지 않는다.
```

인덱스를 사용한다면 정렬을 유지해야 하기 때문에 insert, update, delete와 같은 저장 과정은 느리지만 조회 성능은 빨라진다.  
(저장속도를 희생하고 조회속도를 높임)

이러한 트레이드 오프 때문에 성능을 높이기 위해 무조건 인덱스를 생성하는 것이 좋지 않다.

<br>

### 인덱스의 종류
> 크게 두가지로 나눌 수 있다.

- `프라이머리 키`: PK에 따라 자동으로 생성되는 인덱스이다. (중복 x, null x)
- `세컨더리 인덱스`: PK가 아닌 어떤 컬럼에 인덱스를 추가한 다는 것은 세컨더리 인덱스를 추가하는 것이다. (중복 가능)

<br>

### 인덱스 저장 방식
> 크게 두가지로 나눌 수 있다.

- `B-Tree 인덱스`: 컬럼 값을 변형하지 않고 원래의 값을 이용해 인덱싱 (대표적인 방법)
- `Hash 인덱스`: 컬럼 값으로 해시값을 계산해 인덱싱 -> 매우 빠른 검색이 가능

`해시 인덱스`는 매우 빠른 검색이 가능한데 `B-Tree 인덱스`보다 자주 사용하지 않는 이유는   
해시 값을 계산하기 위해서는 찾는 데이터의 칼럼값의 전체를 알아야 해시 값을 얻어낼 수 있기 떄문에  
where절의 범위 검색이나(<, >) Like 같은 값의 일부분으로 검색시에는 사용할 수 없다.

<br>
