# 8.3 B-Tree 인덱스
> 컬럼의 원래의 값을 변형하지 않고, 항상 정렬된 상태와 균형을 유지하는 `밸런스 트리`를 이용하여 인덱스를 저장한다.

<br>

## 구조와 특성
B-Tree 인덱스의 구조와 특성에 대해 알아 보도록 하자.

![image](https://github.com/user-attachments/assets/2d1c5ab7-b1e4-4a74-adb0-48f0c4433d7d)

- 각 노드는 페이지 단위로 데이터를 저장한다.
- 리프노드에 실제 데이터 레코드를 찾아가기위한 '주소값' 을 갖는다.
  (세컨더리 인덱스의 경우, 해당 레코드의 PK값을 가진다)
- 항상 정렬된 상태를 유지하는 탐색 트리이다.
- 균형을 유지하는 밸런스 트리

DBMS가 가능하면 삭제된 공간을 재활용 하도록 하기 때문에 데이터 파일은 항상 삽입된 순서대로 디스크에 존재하지 않는다.
그렇기 때문에 인덱스가 가르키는 레코드의 주소는 순차적일 수 없다.

<br>
<br>

### MyISAM과 InnoDB의 세컨더리 인덱스 비교

세컨더리 인덱스에서...

- MyISAM은 리프 노드가 레코드의 물리적인 주소를 가진다.

- InnoDB는 리프 노드가 Pk 값을 가진다.

InnoDB의 세컨더리 인덱스는 리프 노드의 PK 값을 통해 다시 `프라이머리 키 인덱스`를 검색하여 페이지의 데이터를 읽는 방식으로 동작한다.

➡️ InnoDB의 PK인덱스는 `클러스터링 인덱스`인데, 이는 PK 값을 기준으로 실제 데이터 파일을 정렬하여 저장한다.    
(디스크 접근시 랜덤 I/O 줄이고 연속적인 데이터를 읽을 수 있게 하여 성능을 올리기 위해)

➡️  떄문에 PK 값이 바뀌면 레코드가 저장된 물리적 주소가 변하게 되고   

➡️ 레코드 주소가 변하면 세컨더리 인덱스의 값도 변경되어야 하기 떄문에 세컨더리 인덱스는 PK 값을 저장한다.

<br>
<br>

---

## B-Tree 인덱스 키 추가와 삭제

### 인덱스 키 추가

- B-Tree 인덱스는 밸런스 트리이기 때문에 리프 노드가 꽉 차면 분리해야 한다.  
  ➡️ 즉 트리의 구조를 변경해야 한다.  
- 이러한 구조의 변경은 여러 노드 페이지를 읽고 변경해야 하기 때문에 디스크 I/O 비용이 매우 크다.

- MyISAM의 경우에는 insert 시 바로 새로운 키 값을 B-Tree 에 추가하지만
- InnoDB의 경우에는 좀더 개선하여 체인지 버퍼를 이용해 변경된 세컨더리 인덱스 기록을 지연시켜 한번에 작업한다.(디스크 I/O 줄일수 있다.)

하지만 프라이머리 키나 유니크 컬럼의 인덱스의 경우에는 인서트시 바로 중복 체크가 이루어 져야 하기 때문에 체인지 버퍼를 이용할 수 없다.


<br>

### 인덱스 키 삭제
인덱스 키를 삭제하는 경우는 비교적 단순하다.

- 해당 키의 리프 노드를 찾아 삭제된 키에 대해 '마킹'을 해둔다.
- 이렇게 마킹해둔 키 공간은 나중에 재활용(덮어쓰기) 하거나 방치한다.(삭제하지는 않음)

마킹하는 작업도 디스크 I/O가 필요한 작업이다.  
세컨더리 인덱스라면 삭제 시 체인지 버퍼를 이용해 디스크접근 횟수를 줄일 수 있다.

#### Q. 실제 삭제하지 않고 마킹만 하는 이유?
- 동시 요청에서 트랜잭션간 스냅샷을 유지하기 위해 레코드 삭제 즉시 인덱스를 삭제하지 않는다.
- 만약 롤백 요청이 온다면, 다시 트리 구조를 원복시켜야 하기 때문에 이는 많은 오버헤드가 생긴다.
이러한 이유 때문에 삭제 대신 방치 + 덮어쓰기 전략을 선택했다.


<br>

### 인덱스 키 변경
- B-Tree는 정렬을 유지하는 밸런스 트리이기 떄문에 키값이 변경이 되면 트리의 구조 또한 변경이 되어야 한다.
- 키 값을 삭제(마킹) 후 새 키를 추가하는 방식을 사용한다.
- 세컨더리 인덱스라면 체인지 버퍼를 이용 가능

<br>

### 인덱스 키 검색

- 트리를 루트 노드부터 탐색하며, 리프 노드를 찾는 과정이다.  
  (이떄 값의 업데이트 삭제 경우에도 값의 위치를 찾아야 하기 때문에 탐색이 필요하다.)
  
- 만약 조회 시 인덱스 키 값에 변형이 있다면? (함수나 연산 수행결과로 조회 키 값이 변경된 상황)  
  ➡️ B-Tree인덱스에 존재하는 키 값이 아니므로 인덱스를 적용할 수 없다.
  
- 인덱스를 통한 조회는 `동등조건(= or <> or in...)` `앞부분 일치(Like 'asd%')`, `부등호 비교` where 조건에서만 사용이 가능하다.   
  ```
  인덱스를 구성하는 키 값의 뒷 부분만 검색하는 경우 (like '%asd%')에는 인덱스를 사용할 수 없고
  full 테이블 스캔을 사용해 해당 조건을 만족하는 레코드를 찾을 수 있다.
   (B-Tree는 맨 앞의 값부터 정렬/분기하고 내려가기 때문에 앞부분 일치에는 사용가능하지만 뒷부분일치에는 불가하다)
  추가로 부등호 비교가 가능한 이유에는 정렬되어 있으므로 조건값만 비교하면 쉽게 해당 범위의 데이터를 찾을 수 있다.
  ```

- InnoDB는 삽입 수정 삭제 시 대상 레코드를 찾을 때 인덱스 탐색 경로를 따라 잠금이나 넥스트 키 락이 걸리게 된다.  
  때문에 인덱스가 없다면 full 테이블 스캔을 해야 하고, 이때 스캔한 모든 데이터에 대해 잠금이 걸리기 떄문에
  락이 걸리는 대상이 커질 질 수 있다.


<br>
<br>

---

## B-Tree 인덱스 사용에 영향을 미치는 요소
B-Tree 인덱스 사용시 다음의 세가지 요소가 성능에 영향을 끼친다.

1. 인덱스 키 칼럼의 크기
2. 유니크한 인덱스 키 컬럼의 수
3. 읽어야 하는 레코드 수


### 1. 인덱스 키 칼럼의 크기

- 인덱스의 노드는 각각 페이지 단위로 저장된다.

- 키가 가르키는 자식 노드의 주소는 평균적으로 2 바이트 크기인데 페이지의 크기는 전체 16KB 이다.  
  ➡️ 즉 인덱스 키 컬럼 값의 크기에 따라
  ➡️ 한 페이지 내에 저장할 수 있는 인덱스 키-값(칼럼값-자식주소) 엔트리 수가 결정되고,   
  ➡️ 이 엔트리 수는 가질 수 있는 자식 노드의 개수가 결정된다는 것을 의미한다.

- 인덱스 키 칼럼 값의 크기에 따라 디스크 I/O 횟수에 영향을 미치게 된다.

```
인덱스 키 컬럼 크기: 16바이트 -> 한 페이지에 담을 수 있는 인덱스 키 수 585개 = 자식 노드의 수 585
인덱스 키 컬럼 크기: 32바이트 -> 한 페이지에 담을 수 있는 인덱스 키 수 372개 = 자식 노드의 수 372

select 쿼리가 500개의 레코드를 읽어야 한다면?
전자는 최소 1개의 페이지만 읽을 수 있고
후자는 최소 2개의 페이지를 읽어야 한다.
-> 이는 인덱스 키 칼럼 값의 크기에 따라 디스크 I/O 횟수에 영향을 미치게 된다.
```

- 인덱스 키 칼럼 값의 크기에 따라 실제 데이터를 캐싱해 둘 버퍼 풀의 공간이 영향을 받는다.  
  ```
  인덱스 키 값이 커지면... 
  인덱스의 크기도 커지고
  -> 버퍼 풀(or 키 캐시) 영역에 캐싱해둘 인덱스 데이터 크기가 커지고 
  -> 다른 데이터를 캐싱해 둘 메모리의 공간이 줄어들게 된다.  
  (인덱스는 많이 읽게 되기 때문에 웬만해서는 버퍼 풀에 올라가 있다고 생각을 하면 다른 데이터의 캐싱 공간이 줄어든 다는 것은 설득력이 있다.)
  ```

- 인덱스 키 칼럼 값의 크기에 따라 B-Tree의 깊이가 영향을 받고 이는 디스크 접근 횟수에도 영향을 끼친다.  
  ```
  인덱스 키 칼럼 값이 커지면...
  -> 가질수 있는 자식 노드 수가 작아지고 
  -> 트리의 깊이가 깊어진다.
  -> 같은 레코드 수를 가져도 트리의 깊이가 깊어져 디스크 접근 횟수가 증가한다.
  ```

정리하자면 
인덱스 키 값의 크기를 가능한 작게 해야 트리의 깊이가 줄고 디스크 접근횟수가 줄어 성능의 향상을 기대할 수 있다.

```
cf) 깊이가 3인 경우 인덱스에 담을 수 있는 키값의 개수는... 
1. 키 값이 16바이트 라면?
-> 1 페이지에 담을 수 있는 자식 개수 = 585
-> 585 * 585 * 585 = 약 2억

1. 키 값이 32바이트 라면?
-> 1 페이지에 담을 수 있는 자식 개수 = 372
-> 372 * 372 * 372 = 약 5천만

별거 아닌것 같지만 엄청난 차이가 나게 된다.
```


<br>

### 2. 유니크한 인덱스 키 컬럼의 수
> 인덱스는 유니크한 키 컬럼이 많을 수록 스캔을 빠르게 처리할 수 있다.


- 선택도(기수성): 모든 인덱스 키 값 가운데 유니크한 값의 수  
  ➡️ 키 값이 100 일때 유니크한 값이 10개 라면 선택도 = 10  
  ➡️ 즉 중복 값이 많아질 수록 선택도는 낮아진다.

인덱스는 선택도가 클수록(중복값이 적을 수록) 검색 대상이 줄기 떄문에 빠르게 처리 할 수 잇다.

```
튜플 개수가 1000개일때...
1. 유니크 컬럼 10개
-> 1000/10 = 100 건이 일치하여 이 100 건 중 다시 where 조회 조건을 스캔해야 한다.

2. 유니크 컬럼 100개
-> 1000/100 = 10 건이 일치하여 이 10 건 중 다시 where 조회 조건을 스캔해야 한다.

즉 유니크 값의 개수에 따라 인덱스 쿼리의 효율성에 영향을 미친다.
```




<br>
### 3. 읽어야 하는 레코드 수

- 테이블에 있는 대부분의 레코드를 읽어야 하는 경우네는 인덱스를 통한 읽기 보다 `Full 테이블 스캔`을 하는 것이 효율적일 수 있다.
- 모두 개별적으로 읽는 다면 인덱스 트리 탐색 후 타고 타고 레코드를 찾는데 이 인덱스 트리를 탐색하는 과정도 비용이 들기 때문에 많은 데이터를 읽는다면 인덱스를 사용하지 않는 것을 고려해 볼만 하다.
- 풀 테이블 스캔을 한다면 인덱스 트리 탐색이 필요 없고 순차 I/O를 통해 데이터를 빠르게 가져올 수 있어 빠르게 처리할 수 있다.

옵티마이저는 전체 테이블의 20%~25% 이상 읽는다 판단되면 인덱스를 사용하지 않고 `풀 테이블 스캔`을 사용한다.

<br>
<br>
---

## B-Tree 인덱스를 통한 데이터 읽기
대표적인 세가지 방법을 알아보자.

### 1. 인덱스 레인지 스캔
- 세가지 중 가장 빠른 방식
- 레인지 스캔이란 검색해야하는 인덱스의 범위가 결정되었을 경우에 사용할 수 있다.
```sql
select * from 직원 where 이름 between 'Edde' and Gad'
```

![image](https://github.com/user-attachments/assets/47a0567f-f3cf-4331-ac48-ae39b4417a6a)
1. 리프 노드 까지 찾아 들어가 범위 시작점 찾음
2. 시작점 부터 스캔 하다 노드 페이지 끝에 도달하면 연결된 링크로 다음 리프 노드 페이지로 이동
3. 범위 끝에 도달하면 읽은 레코드를 반환

디스크의 접근은 다음과 같이 이루어 진다.
![image](https://github.com/user-attachments/assets/ea786df4-837b-487c-a35c-f60158ed8d81)
- 레코드 주소로 디스크 접근시 레코드 건별로 1건 1건 씩 랜덤 I/O를 통해 데이터 페이지를 가져온다.  

이렇듯 인덱스를 통한 읽기 작업은 비용이 많이 들 수가 있다.

[읽기 과정 요약]
1. 인덱스 탐색 - 인덱스에서 조건을 만족하는 값이 저장된 위치 찾기
2. 인덱스 스캔 - 1에서 탐색된 위치부터 차례로 읽기
3. 레코드 주소를 바탕으로 저장된 페이지를 가져오고 최종적으로 레코드를 읽는다.

쿼리가 필요로 하는데이터에 따라 디스크에 접근하는 3번 과정이 필요하지 않을 수 있는데 이를 `커버링 인덱스`라고 한다.

### 커버링 인덱스
> 쿼리가 필요한 모든 컬럼이 인덱스에 포함되어 있어서, 테이블(=클러스터 인덱스)까지 추가적으로 접근할 필요가 없는 인덱스

예를 들어 인덱스가 다음과 같이 생성되었다면
```sql
CREATE INDEX idx_email_age ON user(email, age);
```
쿼리시 email, age 값만 필요하다면 
```sql
SELECT age FROM user WHERE email = 'abc@x.com';
```
인덱스로 생성한 컬럼으로 조회에 필요한 컬럼둘울 커버를 할 수 있다.

이는 디스크에 접근을 하지 않아도 되어 랜덤 읽기가 상당히 줄어 성능이 빨라진다.

<br>

### 2. 인덱스 풀 스캔
> 인덱스의 리프 노드를 처음부터 끝까지 모두 읽는 방식이다.(즉 인덱스를 모두 읽는 것이다.)

- 쿼리에 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아닌 경우에 사용된다.  
  ```
  인덱스가 여러 컬럼으로 구성되면 (이메일, 이름)
  이메일 순 정렬 -> 이름 순 정렬 이되므로
  두번쨰 컬럼은 이메일이 확정 되어야 정렬성을 활용하여 인덱스 트리를 차례대로 탐색이 가능하다.
  이말인즉슨 where 조건절에 가장 첫 인덱스 컬럼이 존재하지 않으면 인덱스 레인지 스캔이 불가능하고 인덱스 풀 스캔을 해야 한다.
  ```
- 이떄 인덱스에 컬럼만으로 쿼리의 처리가 가능해야 `인덱스 풀 스캔`을 할 수 있다.
- 다른 컬럼이 조건절에 들어 있으면 `풀 테이블 스캔`을 해야 한다.

[인덱스 풀 스캔 동작]
![image](https://github.com/user-attachments/assets/22bf0afe-1362-45be-80a4-3a36dbc16d3c)
- 리프 노드의 페이지 앞 뒤로연결된 링크를 통해 풀 스캔을 진행할 수 있다.
- 풀 테이블 스캔보다는 스캔할 테이블 크기가 작기 때문에 효율적으로 데이터를 읽을 수 잇다.  
  (하지만 쿼리의 처리에 인덱스에 포함되지 않는 컬럼이 필요하다면 인덱스 풀 스캔으로는 데이터를 읽을 수 없다.. 데이터 파일에 접근해 인덱스에 없는 컬럼값을 가져와야 하므로)

<br>

### 3. Loose 인덱스 스캔
> 인덱스를 느슨하게(loose) 듬성듬성 읽는 것이다.

- 인덱스의 정렬을 활용하여 필요하지 않는 인덱스 키 값을 무시하고 넘어가며 스캔한다.
- `Group By`, `Min`, `Max` 최적화에 사용할 수 있다.

[Loose 인덱스 스캔 동작]
![image](https://github.com/user-attachments/assets/0cfade4b-e411-47b9-9928-149c24d7d709)
다음의 쿼리가 있다면
```sql
select dept_no, min(emp_no)
from ...
where dep_no between 'd002' and 'd004'
group by dept_no;
```
- 인덱스가 부서, 직번으로 생성됨
- 부서별로 Min(직번)을 찾아야 하므로 각 부서의 emp_no의 가장 첫번째 인덱스만 확인하면 빠르게 읽을 수 있다.


<br>

### 4. 인덱스 스킵 스캔
> 복합 인덱스에서 선두 컬럼 조건이 없을 때, 두 번째 컬럼 이후의 조건만을 이용해
첫 컬럼 값들을 순차적으로 “스킵”하면서 여러 번 범위 탐색하는 기법

인덱스는 인덱스를 구성하는 컬럼의 순서가 매우 중요한데, 컬럼의 순서에 따라 정렬 기준이 바뀌기 때문이다.
하지만 8.0 이상 부터는 옵티마이저가 두번째 컬럼 이후의 조건절 만으로 인덱스를 스캔할 수 있는 `인덱스 스킵 스캔`을 사용할 수 이따.

예를들어 (성별, 생일) 로 인덱스를 생성했다고 하자.

```sql
select * from people where 생일>='2020-10-21'
```
위와 같이 첫 인덱스 컬럼이 존재하지 않는 조건절을 가진 쿼리를 실행하려고 할떄 옵티마이저가 인덱스 스킵 스캔을 사용한다.

[인덱스 스킵 스캔]
- 옵티마이저는 성별 컬럼에서 유니크한 값(나올수 있는 Distint 속성들)을 모두 조회 해서 주어진 쿼리에 내부적으로 성별 조건을 추가한다.

```sql
select 성별, 생일 from people where 성별 = 남자 and 생일>='2020-10-21'
select 성별, 생일 from people where 성별 = 여자 and생일>='2020-10-21'
```
위와 같은 형태로 쿼리를 하게 된다.

![image](https://github.com/user-attachments/assets/caec2e1d-5156-4077-b0c5-b9a710415edc)

- 이렇게 선두 컬럼의 조건이 추가가 되면 위와 같이 레인지 스캔으로 조회 최적화가 가능해 진다.

하지만 단점이 존재한다.

- 선두 조건절의 유니크한 값의 개수가 적어야 한다.  
  ➡️ 선두 컬럼의 유니크 값이 많으면 레인지 스캔 시작 시점을 검색하는 작업이 많아져 오히려 성능이 떨어질 수 있다.


- 쿼리가 인덱스에 존재하는 컬럼만으로 처리가 가능해야 한다.  
  ➡️ `select *` 를 한다면 다른 컬럼의 값을 조회해야 하므로 스킵 스캔을 하지 못하고 풀 테이블 스캔을 해야 한다.


<br>
<br>

---

## 다중 컬럼 인덱스
> 다중 컬럼 인덱스에서는 컬럼의 순서가 인덱스를 통한 조회 성능에 큰 영향을 끼친다.

이러한 이유는 두번째 컬럼의 정렬은 첫번째 컬럼에 의존적이기 떄문이다.
(즉 두번째 컬럼의 정렬은 첫번째 컬럼의 값이 같을 떄 의미가 있다.)

![image](https://github.com/user-attachments/assets/4847f435-1a00-4456-a766-ba2765e0c0e4)


<br>
<br>
---
## B-Tree 인덱스의 정렬 및 스캔 방향
인덱스의 스캔 방향에 따라 
`top-down`: 오름차순으로 읽을 수 있고
`bottom-up`: 내림차순으로 읽을 수 있다.

이러한 스캔 방향은 옵티마이저가 만든 실행 계획에 따라 결정된다.

### 인덱스의 정렬 
> 인덱스 정렬 기준을 생성시 설정할 수 있다.
```
create index 인덱스명 on 테이블 명 (컬럼1 asc, 컬럼2 desc);
```
<br>

### 인덱스 스캔 방향
인덱스는 위에서 언급했듯 스캔 방향을 바꿔 오름/내림차순 쿼리를 최적화 한다.

![image](https://github.com/user-attachments/assets/9f7db7c6-3fa4-4164-9517-218c3015da5a)

옵티마이저는 그룹 바이나 min max 함수의 최적화가 필여할 때도 스캔 방향을 정할 수 잇따.

### 인덱스 역순 정순 스캔의 성능차이
> 인덱스의 스캔 방식 성능 - `정순 스캔 쿼리` > `역순 스캔 쿼리`

이러한 성능 차이의 이유는 다음과 같다

- 페이지 잠금이 정순 스캔에 적합한 구조이다.
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결되어 있기 때문이다. (단방향 슬롯 배열)

이러한 이유 떄문에 자주 사용하는 쿼리에 따라 인덱스의 정렬 전략을 잘 선택해야 한다.


<br>
<br>

---

## 인덱스의 가용성과 효율성
인덱스를 어떤 경우에 사용할수 있는지 살펴 보도록 하자.

### 비교 조건의 종류와 효율성
> `동등비교`인지, `범위비교`인지에 따라 인덱스의 활용 효율이 달라진다.

```sql
select * from 직원 where 부서번호='d002' and 직번 >= 1014
```
해당 쿼리에 대해

#### 케이스 1. INDEX(부서번호, 직번)
`부서번호='d002' and 직번 >= 1014` 해당 조건을 만족하는 시작 레코드를 찾고 `부서번호='d002'`일 때 까지 쭉 스캔하면 된다.

즉 딱 필요한 만큼만 비교 연산을 실행할 수 있따.

#### 케이스 2. INDEX(직번, 부서번호)
` 직번 >= 1014 and 부서번호='d002'` 레코드를 찾고 그 이후의 모든 레코드에 대해 `부서번호='d002'`인지 비교하며 스캔해야 한다.

즉 필요하지 않는 레코드에 대해서도 비교를 해야 하므로 비효율적으로 인덱스를 이용하게 된다.

![image](https://github.com/user-attachments/assets/bfa04ac0-0a02-4042-8090-81fa5e441de2)



- 케이스 1는 두번쨰 인덱스가 비교 작업 범위를 줄인데 도움이 되었고
- 케이스 2는 두번때 인덱스가  비교 작업 범위를 줄인데 도움이 x
- 2번 케이스의 경우에는 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사 선택하는 `필터링`작업이 필요하다.

1에선 `부서번호`, `직번` 모두 `작업 범위 결정 조건`이 되었고
2에선 `직번`은 `작업 범위 결정 조건`이고 `부서번호`는 `필터링 조건`이 되었다.

쿼리에서 `작업 범위 결정 조건`이 많을 수록 좋은 성능으로 쿼리를 실행 가능하다.
(필터링 조건은 성능에 영향이 없거나 느리게 함)


<br>

### 인덱스의 가용성

인덱스는 왼쪽값 기준으로 정렬된다. 

이는 한 컬럼 내에서도 왼쪽 문자를 기준으로 정렬된다.

그러므로 `Like '%이름'` 같은 조건절의 경우에는 기준이 되는 왼쪽 값을 알 수 없으므로
인덱스 스캔을 사용할 수 없다.


<br>

### 인덱스의 가용성 효율성 판단.

[인덱스를 사용할 수 없는 경우]
(작업범위 결정조건으로 사용할 수 없는 경우)

1. Not-Equal 로 비교된 경우 (<>, not in, is not null...)

2. Like '%asd' 와 같이 뒷부분 일치의 패턴 비교

3. 함수나 연산자로 인덱스 컬럼의 값이 변형된 이후  
   - substring(), lower()...

5. Not-deterministic 함수가 비교조건에 사용된 경우  
   - where 컬럼 = 랜덤함수 같은(Not-deterministic)

7. 데이터 타입이 서로 다른 경우(인덱스 칼럼으 타입을 변환해야 비교가 가능한 경우)

8. 문자열 데이터 타입의 콜레이션이 다른 경우


<br>

[다중 컬럼의 경우]

작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
- 선행 컬럼에 대한 조건이 없는 경우
- 선행 컬럼의 비교 조건의 위의 사용 불가 조건 중 하나인 경우

작업 범위 결정 조건으로 인덱스를 사용할 수 있는 경우
- 앞의 모든 선행 컬럼들이 동등비교일때(in, =)
- 최후의 컬럼이 위의 사용 불가 조건이 아닐때

즉 선행 인덱스가 `작업 범위 결정 조건`이여야 
다음의 인덱스가 `작업 범위 결정 조건`일수 있다.

이렇게 `작업 범위 결정 조건`으로 쿼리를 짜면 인덱스의 효율을 끓어 올릴 수 있다.
