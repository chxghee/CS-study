# 8.8 클러스터링 인덱스

InnoDB에서는 레코드를 저장시 PK 값을 기준으로 데이터 파일에 클러스터링 하여 저장한다.

즉 PK 값이 변하는 상황이 생기면 물리적 저장 위치 또한 변경되어야 한다.

#### Q. PK 순으로 클러스터링 해 저장하는 이유?
> 디스크 I/O를 최소화 할 수 있기 때문이다.
```
범위 조회시 PK 가 연속되어 저장된다면 인덱스 트리에서 시작 위치만 찾고
리프 노드를 순차적으로 한 방향으로만 순차 I/O로 스캔이 가능하다.
```

- 클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼 값이 저장된다.  
  즉, 리프노드에 도달하면 모든 데이터를 읽을 수 있따.

<br>

#### Q. PK 가 없는 테이블에서는?
> 1. not null의 유니크 컬럼중 첫번쨰 인덱스를 클러스터링 키로 선택
> 2. 이마저도 없으면 내부적으로 자동 증가 유니크 컬럼을 추가한다.(이는 실제 사용자에 쿼리에 사용될 수 없다.)


<br>
<br>

---

## PK 인덱스가 세컨더리 인덱스에 미치는 영향

### 1. MyISAM 엔진
- 한번 삽입된 레코드는 PK 값이 변해도 저장 위치가 절대 이동하지 않는다
- 즉 레코드 저장 주소가 변하지 않아 세컨더리 인덱스의 리프 노드가 레코드 저장 주소를 가지고 있다.  
  (PK인덱스와 세컨더리 인덱스는 구조적으로 동일하다.)

즉, 세컨더리 인덱스 검색 -> 레코드 주소 겟 -> 이 주소로 최종 레코드 가져옴

<br>

### 2. InnoDB 엔진
- 세컨더리 인덱스는 해당 레코드의 주소가 아니라 PK 키를 값으로 갖는다
- PK 변경시 레코드 주소또한 변경되므로 세컨더리 인덱스에서 레코드 주소를 저장한다면 이를 모두 수정해야 하는 오버헤드를 없애기 위함

즉, 세컨더리 인덱스 검색 -> Pk 겟 -> PK 인덱스 탐색 -> 리프노드의 레코드 가져옴

<br>
<br>

---

## 클러스터링 인덱스의 장단점
| 구분 | 내용 |
|------|------|
| **장점** | - 프라이머리 키(클러스터링 키)로 검색할 때 처리 성능이 매우 빠름 (특히, 프라이머리 키를 범위 검색하는 경우 매우 빠름 -> 순차 I/O가 가능) <br> - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음 (이를 커버링 인덱스라고 한다.) |
| **단점** | - 테이블의 모든 세컨더리 인덱스가 클러스터링 키 값을 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐 <br> - 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한 번 검색해야 하므로 처리 성능이 느림 <br> - INSERT할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림 <br> - 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느림 |



<br>
<br>

---
## 클러스터링 테이블 사용시 주의 사항

### 1. 클러스터링 인덱스 키 의 크기를 작게 해라
- 세컨더리 인덱스는 PK 키 값을 포함하므로 PK 의 크기가 커지면 세컨더리 인덱스의 크기 또한 커진다.  
  ➡️ 버퍼 풀이나 메모리에 적재할 다른 데이터들의 공간이 줄어든다.

### 2. PK는 Auto Increament 보다 업무적으로 의미를 갖는 값으로 설정해라
- PK 값에 의해 디스크 내 저장 위치가 결정되므로, 업무적으로 의미를 갖는 값으로 설정을 하면(컬럼을 대표하는 값) 디스크 접근 횟수를 줄일 수 있다.  
  ➡️ 고객번호, 주문번호 같이 업무적인 값으로 설정하면 데이터가 업무 흐름에 맞게 정렬되어 스캔 시 랜덤 I/O를 줄일 수 있다.

- UUID 같이 랜덤한 의미 없는 값으로 설정하면 삽입 시 물리적 레코드 위치를 다시 정렬(끼워넣기) 해야 하므로 성능이 안좋다.

```
업무적 의미 있는 PK가 반드시 성능 좋다는 건 아니다.  
→ 무조건이 아니라 “정렬이 잘 되는 경우에만” 유리하다  
(그렇지 않다면 Auto Increment도 괜찮음.)
```

### 3. PK는 반드시 지정해라
- PK를 지정하지 않는다면 내부적으로 Auto Increament 로 PK 를 생성하는데 이는 실제 사용할 수 없다.  
  ➡️ 그럴 바에야 직접 생성해서 지정하면 조회시 사용할 수 있으니 생성하는게 무조건 이득

### 4. PK 크기가 길어진다면(복합키) Auto Increament 컬럼을 인조 식별자로 사용해라
- 복합키의 경우 세컨더리 인덱스가 필요하지 않다면 그냥 써도 된다.  
  ➡️ PK가 커서 세컨더리 인덱스의 크기 증가로 인한 성능저하를 고려 안해도 되기 떄문
- 만약 세컨더리 인덱스가 필요하다면 Auto Increament 컬럼을 PK 로 지정 해 키로 사용한다면 인덱스 크기를 작게 유지 할 수 있다.  

인조 식별자 : PK 를 대체하기 위해 인위적으로 추가한 키
