## Interrupt
>  프로그램을 중단하는 이벤트를 인터럽트라고 합니다.

OS가 인터럽트를 처리하는데 인터럽트가 발생한 프로그램을 정상 실행 할지, 중단하고 다른 프로그램을 실행할지 결정합니다.

이때 중요한 것은, 인터럽트는 프로그램에서 직접 다루는 것이 아니라 **특정 상황에서 하드웨어(CPU)가 감지하고  발생시킵니다.**


인터럽트의 종류는 다음과 같습니다.

### 1. 프로그램 인터럽트
> 프로그램일 실행되는 과정에서 발생하는 인터럽트입니다.

프로그램이 실행되면서 인터럽트가 발생할 수 있는 경우는 크게 다음과 같습니다.

1. 오버 플로우
2. 0으로 나누기
3. 존재하지 않는 명령어 실행
4. 다른 곳에 할당된 메모리를 사용하려 할때 (허용된 메모리 공간 밖을 참조)

위와 같은 상황이 발생하면 명렁어를 처리하던 하드웨어(CPU) 가 인터럽트를 발생시킵니다.


### 2. 타이머 인터럽트
> 프로세서의 타이머에 의해 발생하는 인터럽트입니다.

OS가 특정 기능을 정규적으로 수행할 수 잇도록 하는 것인데요,
쉽게 말하면, OS가 프로그램을 실행하다 오래 걸리면 해당 프로그램을 기다리지 않고 다른 프로그램을 실행하는 것입니다.

### 3. I/O 인터럽트
> 입출력 제어기에 의해 발생하는 인터럽트 입니다.

연산의 정상적 종료를 알리거나 에러 발생유무를 알리는 인터럽트입니다.

A를 실행중이다가 입출력이 필요해 다음 프로그램 B가 실행 중인 상황일때,
A의 입출력이 작업 끝나면 인터럽트를 발생시켜 다시 A로 프로그램을 전환할수 있게 합니다.


### 4. 하드웨어 Failure
> 전원 결함 등 하드웨어에 문제가 발생하여 프로그램을 멈추기 위해 OS가 발생시키는 인터럽트입니다.


<br>
<br>

## 인터럽트 흐름 
![](https://velog.velcdn.com/images/chxghee/post/226d0f91-8ce5-4c2e-9ab0-7a74798814b2/image.png)


우선 왼쪽 인터럽트가 없을 떄의 흐름에 대해알아 보도록 하겠습니다.

### 인터럽트가 없다면..
1. 유저 프로그램 실행 후 `Write` 명령 발생

2. I/O 프로그램을 실행 

3. I/O Command 실행하여 입력을 받습니다.

4. 입력이 끝나면 다음 작업을 계속합니다.

이렇듯 I/O 입출력 동안 CPU가 노는 시간이 발생합니다.

### 인터럽트가 있다면..

1. 유저 프로그램 실행 후 `Write` 명령 발생

2. I/O 프로그램을 실행 

3. CPU는 입력 받기를 기다리지 않고, 다음 작업을 계속 합니다.

4. 입력 작업이(I/O Command) 종료되면 인터럽트가 발생합니다.

5. CPU는 하던 작업을 멈추고 입출력 장치를 서비스 하기 위한 인터럽트 핸들러를 실행합니다.

6. 핸들러의 처리가 완료되면 이전 작업을 계속합니다.


<br>
<br>

인터럽트의 처리 흐름을 하드웨어와 소프트웨어를 나누어 살펴 보겠습니다.

![](https://velog.velcdn.com/images/chxghee/post/29e7d59b-8a9b-4913-89c3-8728453de2ca/image.png)

### [하드웨어]
1. 장치 제어기나 다름 시스템 하드웨어가 인터럽트 발생시킴

2. CPU는 현재 실행중이던 명령어를 끝까지 실행
(끝까지 실행하는 이유는 처리하지 않고 인터럽트 핸들러를 실행하면, 실행되전 PC가 복구 되어도, IR에서 실행 중이던 명령어를 복구할순 없기 때문에 실행 중이던 것은 마저 마무리를 하고 인터럽트를 처리한다.)

3. CPU가 인터럽트 확인 신호를 보낸다

4. CPU가 PSW와 PC를 제어 스택(메모리)에 저장한다. 
(다음 명령을 마저 실행하기 위해)

5. CPU는 인터럽트핸들러의 명령어에 해당하는 새로운 PC값을 적재한다.



### [소프트웨어 (인터럽트 핸들러)]

6. CPU의 나머지 상태정보 저장 
(PSW, PC이외의 작업 상태를 저장합니다.)

7. 인터럽트 핸들러의 명령을 실행

8. 처리가 끝나면 CPU의 상태 정보를 복구합니다.
(먼조 6번에서 소프트웨어 적으로 저장했던 정보를 복구하는데 이 이유는 새 PC가 적재되면 바로 다음명령이 실행되는데 중요 상태 정보를 적재하지 못한 채 실행될 수 있기 때문입니다.)

9. PC, PSW를 복구


#### Q. PC, PSW를 소프트웨어 적으로 처리(저장)하지 못하는 이유?

> 소프트웨어 적인 처리는 인터럽트 핸들러 즉, OS가 하는데, 이때 인터럽트 핸들러의 명령어로 PC 값을 바꾸기 때문에 실행하던 PC, PSW의 값을 저장하지 못하기 떄문입니다. (PC 가 이미 OS 주소로 바뀌기 때문에 이전 상태값을 저장할 수 없겠죠.)




<br>
<br>

---

## 메모리 계층 구조

![](https://velog.velcdn.com/images/chxghee/post/a78ab9d9-8db9-4863-9815-fa792c579fb0/image.png)


메모리는 계층적으로 설계가 되어 있습니다.

- 접근시간이 늘어날 수록 -> 비용이 커지고
- 용량이 커질수록 -> 비용은 작아지지만, 접근시간이 길어지기 때문에 

위의 계층적인 구조에서 하위 레이어로 갈 수록 싸지지만, 접근시간이 매우 길어집니다.

때문에 프로그램의 실행 속도를 올리기 위해서는 낮은 레벨 억세스의 빈도를 줄여야 합니다.

(이러한 특성을 이용하기 위해 메모리는 계층적으로 설계가 된 것 같습니다.)

```
cf) 참조 지역성
프로세서의 메모리 참조는 인근 지역(가까운 데이터) 에 몰리는 경향
```



### 캐시 메모리
> 메인 메모리와 CPU사이에 존재하는 메모리 입니다.

프로세서의 연산 속도는 메모리의 속도 보다 빠릅니다.
이러한 속도 불균형으로, CPU는 메모리를 기다리게 되고 이는 프로그램 실행 전반의 병목이 될 수 있습니다.

때문에 캐시 메모리 라는 것은 중간에 두어 프로그램 일부를 캐시에 저장해 메인 메모리에 직접 접근하는 것 보다 훨씬 빠른 속도로 데이터에 접근할 수 있도록 합니다.
(이때 캐시에 올려 둘 데이터의 분포는 지역성의 원리가 적용됩니다.)

이때 캐시의 관리는 OS가 관여하지는 않습니다.


<br>
<br>


---

## I/O 연산

### 1. Programed I/O
> I/O 프로그램을 OS가 실행을 하고 입출력 장비가 입출력을 하는 동안 CPU는 노는 것 입니다.

어떠한 인터럽트 처리도 하지 않고, 그저 기다리는 것 입니다.


### 2. Interrupt-driven I/O
> 입출력 장비가 작업을 하는 동안에 CPU는 다른 프로그램을 실행하다가,  I/O 작업이 다 끝나 인터럽트가 걸리면 입출력 작업을 마무리 하고, 하던 작업을 계속 하는 것 입니다.



### 3. 직접 메모리 접근 (Direct Memory Access)
> 데이터가 CPU를 거치지 않고 입출력 장비 <-> 메모리 로 직접 접근을 하는 것 입니다.


파일 입출력 같이 **한 번에 많은 데이터를 입출력 할때** 사용됩니다.

CPU가 DMA 모듈에 입출력 작업 지시 후 자신의 작업을 마저 이어합니다.

CPU는 전송의 시작 끝에만 관여합니다.(작업 지시)


---

<br>

## SMP (Symmetric Multi Processors)
> 2개 이상의 CPU가 한 개의 공유된 메모리를 사용하는 다중 프로세서 아키텍쳐 입니다.

![](https://velog.velcdn.com/images/chxghee/post/58bc3efe-30fa-4516-8583-db8cde17ec90/image.png)

이때 하나의 메모리를 공유하기에 메모리 억세스를 대기하는 시간이 길어질 수 있습니다.

-> 실제 속도가 CPU의 개수 대로 비례하지 않습니다.


## Multicore Computer
> 칩 하나에 많은 CPU가 들어 있는 아키텍쳐입니다.

![](https://velog.velcdn.com/images/chxghee/post/3f942ff8-b32e-4b40-ab8e-844daf933e0b/image.png)


1개가 추가된 3단계의 캐시를 가지며, 이때 마지막 캐시는 칩 내에서 CPU들이 공유하는 캐시 구역 입니다.
