
# 생성 과정

### 1. 프로세스에 유일한 식별자 할당

### 2. 프로세스에 공간 할당(메모리)

- 프로세스를 실행하려면 당연히 메모리를 할당해 주어야 한다.
- 사용자 주소 공간(프로그램 코드. 데이터)
    - 해당 공간은 프로세스 별로 가지는 공간이다.
- 사용자 스택
    - 스택은 실행 중에 쌓이는 데이터

### 3. PCB 초기화

- PCB
    - 부모의 프로세스의 PCB를 복사하여 자식 프로세스를 만듬
- 하드 디스크 스와핑 에어리어에 공간 할당

### 4. 적절한 링크 연결

> 만들어진 프로세스가 들어갈 자료구조 세팅
> 
- 프로세스 트리(부모-자식)
- 테이블
- 큐

### 5. 다른 자료구조 생성 or확장

- 자원 할당



<br>
<br>

# 프로세스 스위칭

### 참고) 고려할 점

1. 언제 플세스 스위칭이 일어나는가?
2. 프로세스 스위칭과 모드 스위칭의 다른점?

## 1. 프로세스 교환 시점

- OS가 RUNNING 프로세스로부터 제어를 넘겨 받을 때 발생
- 다음의 세가지 이벤트에 의해 OS에게 제어가 넘어간다.
    - 인터럽트
    - 트랩
    - 수퍼바이저 호출

### 1) 인터럽트

> 현재 명령어의 외부적 요인으로 발생 (프로그램의 에러로 인한 것이 아님)
> 
- 클럭 인터럽트 (타이머 인터럽트)
    - 현재 프로세스가 레디 상태로 전이
- IO 인터럽트
    - 입출력이 끝나면 관련된 프로세스를 모두 BLOCK → READY 로 변경
    - 현재 실행중이던 프로세스는
        - 다시 이어실행(RUNNING)
        - 혹은 입출력이 끝난게 더 우선순위가 높다면 현재 프로세스는 READY
- 메모리 FAULT (메모리 부재)
    - 실행중 메인 메모리에 없는 워드를 가상메모리에서 가져와야 할때.
        - 수행중이던 프로세를 BLOCK 으로 바꾸고,
        - 메모리 블럭이 적재되면 READY로


### 2) 트랩

> 내부적 요인으로 발생 (프로그램 오류)
> 
- 치명적인 오류라면 실행중이던ㄷ 프로그램을 EXIT 상태 (종료)
- 치명적이진 않다면 BLOCK상태로

### 3) 수퍼바이저 CALL

> OS의 기능을 요청하는 명시적 요청이 프로그램에 있을때
> 
- 파일 입출력 , 동기화 함수 호출등
- 일반적으로 제어가 OS에 넘어가고 프로세스는 BLOCK 상태로
- 간단한 콜은 OS가 작업하고 다시 RUNNING 상태로

# 모드 스위칭 vs 프로세스 스위칭

### 1. 모드 스위칭

> 프로세스가 바뀌진 않고 모드만 바뀜 (but 컨텍스트 스위칭 일어 남)
User mode A → Kernel mode (OS의 개입) → User mode A
> 
- 여기서 말하는 모드는 CPU의 실행 모드를 뜻함
- user mode
    - 현재 cpu가 유저 프로그램 명령을 1줄을 실행하는 모드
    - 권한에 제한이 많음
- 커널 모드 = 시스템 모드 = 컨트롤 모드 = 수퍼바이저 모드
    - 현재 CPU가 OS 프로그램 명령을 1줄 실행하는 모드
    - 권한에 제약이 적다.

- User mode A를 실행하다 대기 인터럽트 걸리면..
    - pc값을 인터럽트 핸들러 프로그램의 시작 주소로 바꿈
    - 사용자 모드를 커널 모드로 바꾸고 인터럽트 처리 코드가 특권 명령어 실행 할 수 있게 함
    - 중지된 프로그램 상태를 PCB의 처리기 상태 정보 블럭에 저장

### 2. 프로세스 스위칭

> 프로세스도 바뀌고 모드도 바뀜 + 컨텍스트 스위칭  발생
User mode A → Kernel mode (OS의 개입) → User mode B
> 

### [프로세스의 상태 변화]

1. CPU의 상태 저장
    - 프로세서의 컨텍스트를 저장한다
    - pc, register 등  현재 cpu가 실행하던 상태를 저장해 둔다.
2. PCB 내용 업데이트
3. 실행중이던 프로세스를 적절한 큐로 이동
    - 해당 프로세스의 PCB를 이동 (레디큐, 블락 큐 등등으로)
4. 다음에 실행할 프로세스 선택
5. 다음에 실행할 프로레스의 PCB 업데이트
6. 실행을 하기 위해필요한 메모리 자료구조 업데이트
    - 실행할 프로세스의 관련 레디스터 만 가져옴
7. 선택된 프로세스가 이전 수행 상태 정보를 CPU에 복원 


<br>
<br>


# OS의 실행방식

## 1. Non proccess “커널”

> 커널은 프로세스 밖에서 모든 권한을 갖는다.
> 
- os는 프로세스가 아니다.
- 프로세스가 아니라 프로세스처럼 관리 되지 않고, 프로세스와 다른 방법으로 관리하는 실행방식
- 옛날 방식 (os가 작아서 os전체가 메모리에 올라갈 수 있었던 옛날 사용하던 방)

## 2. 유저 프로세스 안에서 실행

> 유저 프로그램 안에서 OS 를 실행시키는 방식
> 
- 유저 프로그램 실행 중 인터럽트나 수퍼바이저 콜이 들어오면 OS실행
- 이때 OS가 별도의 프로그램으로 만들어져서 실행하는 게 아니라 유저 프로세스 안에서 실행하는것
- 입출력 인터럽트의 경우 커널이 유저 프로그램 안에서 실행되니까 프로세스가 스위칭 되지 않고 인터럽트 작업을 처리후 이어서 유저 프로그램을 실행하면 됨
- 즉 모드 스위칭만 하고 프로세스 스위칭 x (빠르긴 하겠죠?)

[프로세스 안에서 실행된다는 말의 뜻]

프로세스를 실행할 때는 프로그램 코드, 데이터는 변화가 거의 없다.

→ 달리 말하면, 데이터가 계속 변하는 것은 스택 영역 밖에 없다.

→ 실행은 스택이 쌓였다가 내려갔다가 값이 바뀌는 것을 말함

→ 즉, 프로세스 안에서 실행된다는 것은 프로세스 안에서 커널이 스택을 쌓아가면서 실행하는 것을 말한다.

프로세스 이미지에 커널 스택이 추가되어 커널 프로세스를 실행한다.

## 3. **Process-Based Operating System**

> 모든 OS코드들도 별도의 프로세스로 관리하는 방식
> 
- 인터럽트가 발생하면 유저 프로그램을 블록 → 커널 프로세스를 실행 → 처리 완료 → 레디상태의 프로세스 실행
- 즉 컨텍스트 스위칭, 모드 스위칭 발생
- 커널의 주요 부분들을 나누어서 여러 프로세스로 분리해 구성
- os를 모듈화 했기 때문에 커널 코드의 확장성이 용이하다.
- 멀티프로세서에서 사용된다.


<br>
<br>


# UNIX SVR4의 프로세스 관리

### 1. UNIX SVR4의 OS 실행 방식

- Execution Within User Processes + Process-Based Operating System 의 혼합된 방식
- 대부분의 OS프로그램들은 유저 프로세스 안에서 실행시킨다

### 2. UNIX SVR4의 프로세스 종류

- 시스템 프로세스
    - 0번 프로세스: 스와퍼 프로세스 (시스템 부팅 시 생성)
    - 1번: init프로세스 (0번 프로세스가 1번 프로게스를 생성하고, 1번 프로세스가 모든 유저 프로세스의 부모)
- 유저 프로세스

```jsx
cf) 프로세스 이미지

1. Program Code
2. Data
3. Stack
4. PCB
    - Process ID
    - Process State Information
    - Process Control Information
```

### 3. 유저 레벨 컨텍스트

1. 프로세스 텍스트
2. 프로세스 데이터: 이 프로세스가 접근 가능한 데이터
3. 사용자 스택: 함수 인자 지역변수 포인터 등
4. 공유 메모리: 다른 프로세스와 공유하는 메모리

### 4.  레지스터 컨텍스트

- 프로그램 카운터: 다음 수행될 명령어주소
- 프로세서(cpu) 상태 레지스터
- 스택 포인터: 커널 스택이나 사용자 스택의 top을 가르킴
- 범용 레지스터

### 5. 시스템 레벨 컨텍스트

- 프로세스 테이블 항목: 프로세스 상태 정의 (메인메모리, 프로세서 제어 정보)
- 사용자 영역 (u area): os가 유저 프로세스 안에서 커널이 실행 될 때 억세스 하는 정보
- 프로세스 당 영역 테이블:
- 커널 스택

<img width="1668" height="1296" alt="image" src="https://github.com/user-attachments/assets/2646b141-5a8f-4152-ad5f-f34f7b4e3c8f" />


- 프로세스가 사용자모드 or 커널 모드인지 가리기 위해 2가지의 running 상태가 존재
    - 커널 러닝
    - 유저 러닝
- 레디 상태
    - `preemepted`
        - 프로세스가 커널 모드 → 사용자 모드 전환시에만 일어남
        - 이때 현재 프로세스보다 높은 우선순위를 가진 프로세스의 실행을 위해 커널이 현재 프로세스를 선점해 버리고 다른 걸로 스위칭한다.
        - 커널 러닝 상태에서 타임 아웃 시 선점 상태로 이동한다.
    - `ready to run in memory`
        - 커널이 프로세스를 스케줄 하자 마자 수행가능한 상태
        - 모든 프로그램은 실행을 시작하려면 Kernel Running 상태를 거쳐야 한다.
