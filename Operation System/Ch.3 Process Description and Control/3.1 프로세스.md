
## 프로세스란?

> **프로세스(process)**는 "**실행 중인 프로그램**"을 말합니다.

즉, **실행의 단위**로서 CPU가 실제로 작업을 수행하고 있는 프로그램 인스턴스를 의미합니다.


운영체제는 프로세스를 관리하기 위해 다음과 같은 것들을 관리합니다.



### 1. 명령어의 순서 (프로그램 카운터 관리)
> CPU가 어떤 명령어를 **어디까지 실행했는지** 기억해야 합니다.

 실행 중 인터럽트가 발생하거나, CPU 할당 시간이 끝나 문맥 교환(Context Switching)이 일어나면 **다시 이어서 실행할 수 있도록** 프로그램 카운터(PC)를 저장합니다.


### 2. 현재 상태(Process State)
> 프로세스는 실행 준비, 실행 중, 대기, 종료 등 여러 **상태(state)**를 가집니다.

OS는 프로세스마다 **현재 상태를 기록**하고, 상태에 따라 적절한 **대기 큐(Ready Queue, Waiting Queue 등)**에 넣어 스케줄링합니다.



### 3. 실행에 필요한 자원(Resource) 관리

> 메모리 공간, CPU 시간, 파일, 입출력 장치 등 프로세스가 동작하는 데 필요한 **각종 자원**을 할당하고 추적합니다.

이러한 정보는 **PCB(Process Control Block)**에 저장됩니다.


<br>

## 프로세스의 구성
> 프로세스는 크게 다음 4가지로 구성됩니다.
1. Program code
2. A set of Data
3. Stack
4. PCB (Process control block)

하나 기억하고 넘어가야 하는 것은 프로새스는 생성될 때 메인 메모리에 유지 되고, 실행이 완료 되면 메모리에서 지워 집니다.

따라서 아래의 데이터들을 프로세스가 종료되면 사라진다고 생각하면 될 것 같습니다.

### 1. Program code
> 실행할 프로그램의 모드를 뜻합니다.


### 2. A set of Data
> 여기서  말하는 데이터는 는 `전역변수`나 `static 변수`를 저장하는 공간 입니다.



### 3. Stack
> 로컬 변수들을 스택에 저장합니다.

프로그램의 함수가 호출될 때 그 함수에서 사용하는 지역 변수들을 스택에 담아 사용하고, 함수가 종료되면 해당 스택 영역에 쌓였던 데이터들을 메모리에서 해제가 됩니다.


### 4. PCB (Process Control Block)
> 프로세스에 대한 전반적인 정보들을 저장하는 공간 입니다.

운영체제는 `PCB`에 담긴 정보를 토대로 프로세스들을 관리하고 제어합니다.

#### [PCB의 구성요소]
1. 프로세스 id
2. 상태
3. 우선순위
4. PC
5. 메모리 포인터
5. 컨텍스트 데이터
6. I/O 상태 정보

OS는 위의 여러 정보를 PCB에 가지고 있습니다.

운영체제는 컨텍스트 스위칭이 일어날때 PCB에 저장된 정보를 토대로 프로세스의 실행을 재개 합니다.

(즉 PCB는 프로세스의 실행에 있어 중요한 상태 정보를 저장하고 있다고 기억하면 될것 같습니다.)

---

<br>





## 디스패처 Dispatcher
> 디스패처는 OS의 일부로, 프로세서를 한 프로세서에서 다른 프로세서로 교체하는 `스위칭` 작업을 수행합니다.

앞서 말했듯 OS의 일부라는 뜻은 디스패처 또한 프로그램이라는 뜻이고, 메인 메모리에 존재합니다.

![](https://velog.velcdn.com/images/chxghee/post/dc5a9b75-5570-4be0-8730-9818b5f2fe76/image.png)


> #### [디스패처의 임무] 
스위칭을 담당한 다는 것은, 
다음에 어떤 프로그램을 실행할지 결정하고, 현재 실행하는 프로그램을 얼만큼 실행시킬지를 결정하는 것이라고 할 수 있습니다.


** -> 디스패처가 존재 하므로써 한 프로세서가 CPU를 독정하는 것을 막을 수 있습니다.**

---

<br>
<br>

## 5가지 프로세스 상태 모델
> 프로세스는 5가지의 상태를 갖습니다.


![](https://velog.velcdn.com/images/chxghee/post/86182fd7-c331-4915-9c68-0b6eab7c246a/image.png)


### 1. New
> 프로세스가 처음 생성된 상태입니다.

프로새스가 생성 되었다고 해도, 생성 당시에는 메인 메모리에 적재가 되진 않습니다.

하지만 상태 정보를 저장해야 하므로, 운영체제는 PCB를 만들어 PCB만 메인 메모리에 저장해 둡니다.


### 2. Ready
> CPU만 주면 언제든지 실행할 수 있는 상태입니다.

메모리에 적재는 된 상태이지만, CPU만 할당되지 않아 준비된 채 기다리는 상태 입니다.

다시말해 CPU만 주어지면 실행 가능한 상태입니다.




### 3. Running
> 프로세스가 할당 되어 CPU를 잡고 실행중인 상태입니다.

### 4. Blocked/Waiting
> 프로세스가 이벤트가(ex. I/O 작업 완료 신호) 발생하길 기다리는 상태입니다.

해당 상태는 CPU가 할당 되어도, 바로 실행할 수 없는 상태입니다.



### 5. Exit
> 프로세스가 중단되어 운영체제에 의해 수행가능 프로세스 집합에서 방출된 상태입니다.

실행을 마치고, 자원을 다 반납한채 사라지길 기다리는 상태입니다.


<br>

`Running` -> `Ready`
- 프로세스가 타임 아웃이 걸리면 레디 상태로 전환됩니다.


`Running` -> `Blocked`
- 프로세스가 자원을 요청했는데(OS의 시스템 콜), 기다려야 할때 Blocked 상태로 전환됩니다. 
(I/O 작업, 프로세스 끼리 통신시 대기등등 상황)


## Multiple Blocked Queue
> OS는 큐를 이용하여 메모리에 올라와 있는 프로세스를 스왑합니다.

이때 중요한 점은 큐도 메인 메모리에 적재되어 관리됩니다.


![](https://velog.velcdn.com/images/chxghee/post/0d6e1fdb-db74-4883-91e8-0375c20de46a/image.png)



### Ready Queue
> Ready 상태들의 프로세스들을 큐로 가지고 있습니다.

Ready Queue에는 ID, PCB를 가르키는 포인터를 저장하고 있습니다.
(프로세스 전체를 큐에 저장하진 않습니다.)

디스패처는 Ready Queue만 확인하며 실행할 프로세스를 선택해 가져옵니다.

### Blocked Queue
> Blocked 상태들의 프로세스들을 큐로 가지고 있습니다.

대개 I/O 작업을 하고 있는 프로세스들이 모이게 됩니다.


### Swapping area
> 메인 메모리에 있던 프로세스가 Blocked 상태로 전이하면, 존재하는 하드디스크의 `Swapping area`로 보냅니다.


### Q. 프로세스 스왑핑의 필요성
1. 입출력 작업 속도가 CPU의 작업 속도에 비해 너무 느려서 스왑핑을 통해 다른 작업들을 수행합니다.

2. 메인 메모리가 한정적이기 떄문
메인 메모리는 한정적이라 몇개의 프로세스만 존재가 가능한데, 메인메모리의 프로세스가 전부 블락 상태이면 블락 상태의 프로세스를 `Swapping area`(일종의 가상 메모리(디스크)) 에 쫒아내고, 실행이 가능한 프로세스들을 다시  `Swapping area`에서 메인 메모리로 올려 보냅니다.
즉, `Blocked Queue`에는 `Swapping area`로 쫒겨난 블락 상태의 프로세스들이 존재하게 됩니다.




정리하자면, 메인 메모리에는 지금 실행중인 프로세스들과 CPU만 할당되면 실행할 수 있는 프로세스만 존재하게 됩니다.
(Ready, Running 상태)


## 프로세스 상태 모델 (with suspend state)

![](https://velog.velcdn.com/images/chxghee/post/0e3a449a-f37d-4b82-be20-e9dba2f40fbf/image.png)


### 1. new -> Ready/Suspend
> 새로운 프로세스가 만들어 졌는데, 메인 메모리의 용량 부족으로, 하드디스크에 있는 상태입니다.


### 2. Blocked -> Blocked/Suspend
> 메인 메모리의 프로세스가 레디 상태가 하나도 없을 때, 블락 상태의 프로세스를 스와핑 에어리어로 보냅니다.

### 3. Blocked/Suspend -> Blocked
> Blocked/Suspend 상태의 프로세스가 Ready/Suspend 상태의 프로세스보다 우선순위가 높고 I/O 작업이 완료될것 같은 프로세스는 메모리에 올려 둡니다.


### 4. Ready -> Ready/Suspend
> OS는 준비 상태의 프로세스를 스와핑 에어리어로 보내고 싶지 않지만, 메인 메모리의 공간이 부족하거나, 높은 우선순위의 Blocked프로세스가 곧 이벤트가 끝나려고 할때 Suspend 시킵니다.


<br>

### 프로세스의 Suspend가 일어나는 5가지 이유

1. 스와핑 (Blocked->Blocked/Suspend->Ready/Suspend->Ready)
	- I/O CPU의 속도차 때문에 모두가 Blocked 상태일 때 메모리 공간이 부족하다면, 프로세스들을 하드 디스크로 보냅니다.
    - 인터럽트가 발생해 I/O 작업이 완료되었다는 신호를 받으면 Ready/Suspend 상태가 되고,
  	- 메모리에 공간이 나면 프로세스를 메인 메모리에 데려오고, Ready 상태가 됩니다.
   
   
2. OS의 다른 이유들 (Ready -> Ready/Suspend)
운영체제는 시스템의 활동을 모니터링 위해 백그라운드 유틸리티 프로세스를 사용하는데, 운영체제가 메모리가 부족하게 되면, 해당 유틸리티 프로세스를 Ready/Suspend 상태로 보내 버릴 수 있습니다.

3. Interactive user request (Running → Ready/Suspend)
사용자가 직접 자원 사용에 관해 프로세스를 보류 시키는 상황입니다.

4. 타이밍 (Ready -> Ready/Suspend)
주기적으로 실행되는 프로세스(모니터링 백그라운드 프로세스)가 다음 주기 까지 대기시 보류될 수 잇씁니다.


5. 부모 프로세스의 요청 (Ready -> Ready/Suspend)
자식 프로세스의 검사 수정 등 부모가 동기화를 위해 자식 프로세스를 보류 시킬 수 있습니다.



